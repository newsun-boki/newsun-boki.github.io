<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-17T17:49:57.108Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu18.04录屏并生成gif图片</title>
    <link href="http://example.com/2021/11/18/ubuntu-record-sc/"/>
    <id>http://example.com/2021/11/18/ubuntu-record-sc/</id>
    <published>2021-11-17T17:47:51.000Z</published>
    <updated>2021-11-17T17:49:57.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu18-04录屏并生成gif图片"><a href="#Ubuntu18-04录屏并生成gif图片" class="headerlink" title="Ubuntu18.04录屏并生成gif图片"></a>Ubuntu18.04录屏并生成gif图片</h1><p>用kazam录屏ffmpeg转gif</p><p>标记一下这篇文章，以免我忘了每次都要去找：</p><p><a class="link"   href="https://blog.csdn.net/RedKeyer/article/details/89519984" >https://blog.csdn.net/RedKeyer/article/details/89519984<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu18-04录屏并生成gif图片&quot;&gt;&lt;a href=&quot;#Ubuntu18-04录屏并生成gif图片&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu18.04录屏并生成gif图片&quot;&gt;&lt;/a&gt;Ubuntu18.04录屏并生成gif图片&lt;/</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ROS新手介绍</title>
    <link href="http://example.com/2021/11/18/ros-begin/"/>
    <id>http://example.com/2021/11/18/ros-begin/</id>
    <published>2021-11-17T17:21:42.000Z</published>
    <updated>2021-11-17T19:05:45.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS介绍"><a href="#ROS介绍" class="headerlink" title="ROS介绍"></a>ROS介绍</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里只是ROS的基础入门的开始，做一个非常简单的讲解。</p><p>一般建议直接看官方文档：<a class="link"   href="http://wiki.ros.org/cn/ROS/Tutorials" >http://wiki.ros.org/cn/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>.</p><p>强烈建议看英文版：<a class="link"   href="http://wiki.ros.org/en/ROS/Tutorials" >http://wiki.ros.org/en/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>. 能够培养你阅读外的能力，毕竟大多数官方教程和写的好的教程是没有中文的。</p><h2 id="什么是ROS，为什么要用ROS"><a href="#什么是ROS，为什么要用ROS" class="headerlink" title="什么是ROS，为什么要用ROS"></a>什么是ROS，为什么要用ROS</h2><p>ROS的全称是<strong>Robot Operating System</strong>，也就是指<strong>机器人操作系统</strong>。但什么才是一个操作系统呢?想想现在都有些什么操作系统，Windows,linux,mac,Android等等，甚至你可能听过DOS系统，一个操作系统的基本特征有些什么呢？为什么ROS可以称为一个操作系统。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/ros.1xue58m21bj4.gif"                                     ></p><h3 id="分布式架构以及多进程"><a href="#分布式架构以及多进程" class="headerlink" title="分布式架构以及多进程"></a>分布式架构以及多进程</h3><p>想想你的Windows系统，你可以一边打游戏，一边看qq，后台还可能挂着杀毒软件，这些都是一个一个进程。一个操作系统运行往往包含大量的进程，但想想你写出来的代码，他可能是按着顺序来的，可能你把它放一个while循环里让他来回跑，或者你也可以多开几个线程让他分别跑着，但是这样还不够。</p><p>一个机器人，可能和人一样，有着眼睛(摄像头取流以及视觉目标检测),有着手(机械臂模块),脚(不同的底盘),还有着很多东西。这些东西光通讯就是一个大问题，更不要说让他们之间尽量互不干扰，但ros可以做到。就像你聊qq不耽误你打游戏一样。<strong>也就是说，在ros上，你实际上是可以运行多个程序，并且能够做到让这些程序间的数据互传。</strong></p><p>事实上，你也可以在其他的操作系统上做到这一点，例如通过SOCKER,管道，TCP协议等，但都没有ros方便快捷清晰。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-11-39.638zlyali1c0.png"                                     ></p><h3 id="功能的划分以及极强的可扩展性"><a href="#功能的划分以及极强的可扩展性" class="headerlink" title="功能的划分以及极强的可扩展性"></a>功能的划分以及极强的可扩展性</h3><p>在不用ros的时候，想想机器人是怎么控制的。冗长的代码，看不懂的结构，更是因为模块众多导致的代码量大，往往不知所措。然而有了ros，一切都不一样了。你可以把每个功能的模块分开，这里的分开不是简单的封装到一个个函数里。而是完全的分开，即多个不同的功能包，多个不同的代码，唯一的连接就是一些消息间的互传。这使得每一个模块结构清晰简单，代码可读性增强，且可扩展性极强。</p><h3 id="良好的生态"><a href="#良好的生态" class="headerlink" title="良好的生态"></a>良好的生态</h3><p>由于ROS得到越来越多机器人制作者的青睐，越来越多的机器人相关硬件软件抖做了ros适配的相关工作。就和Windows上的游戏支持比mac上多的多一样，很多时候你买到游戏没有Windows寸步难行。同样由于很多硬件如激光雷达等对ROS的支持,没有ros寸步难行。良好的生态也决定促使ros愈发蓬勃发展，现如今，ros里集成的大量的库，你可以用它来做slam定位建图导航，也可以用它来做自动驾驶汽车，还有利用第三方软件Gazebo模拟仿真等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-10-30.6000i1mywqg0.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ROS介绍&quot;&gt;&lt;a href=&quot;#ROS介绍&quot; class=&quot;headerlink&quot; title=&quot;ROS介绍&quot;&gt;&lt;/a&gt;ROS介绍&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>图片上传网络</title>
    <link href="http://example.com/2021/11/15/picx/"/>
    <id>http://example.com/2021/11/15/picx/</id>
    <published>2021-11-14T19:03:51.000Z</published>
    <updated>2021-11-14T19:36:46.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="picx图片上传网络"><a href="#picx图片上传网络" class="headerlink" title="picx图片上传网络"></a>picx图片上传网络</h1><p>在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，这个时候一般的选择是先将图片上传到github/gitee或csdn然后再使用网络链接，但还是不够方便，并且github需要翻墙才能看的问题，有个国人大佬就开发了一个名叫<strong>picx</strong>的东西。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/Screenshot-from-2021-11-15-03-07-58.5jhahkkrhcs0.png"                                     ><br>上面这界面就是使用picx上传的，本质上他还是借用了你自己的github仓库去放图片，然而它使用一个叫CDN加速的东西让你的图片可以很快的显示。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>github仓库:<a class="link"   href="https://github.com/XPoet/picx" >https://github.com/XPoet/picx<i class="fas fa-external-link-alt"></i></a></li><li>picx网页地址:<a class="link"   href="https://picx.xpoet.cn/#/upload" >https://picx.xpoet.cn/#/upload<i class="fas fa-external-link-alt"></i></a></li></ul><p>去github仓库看README教你如何在picx网页上配置，记得一定要使用生成的CDN加速的链接，否则就没有意义了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;picx图片上传网络&quot;&gt;&lt;a href=&quot;#picx图片上传网络&quot; class=&quot;headerlink&quot; title=&quot;picx图片上传网络&quot;&gt;&lt;/a&gt;picx图片上传网络&lt;/h1&gt;&lt;p&gt;在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="markdown" scheme="http://example.com/tags/markdown/"/>
    
    <category term="blog" scheme="http://example.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>livox-mid70激光雷达使用实录</title>
    <link href="http://example.com/2021/11/14/livox-detection/"/>
    <id>http://example.com/2021/11/14/livox-detection/</id>
    <published>2021-11-14T14:50:48.000Z</published>
    <updated>2021-11-14T19:36:52.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="livox-mid70激光雷达使用实录"><a href="#livox-mid70激光雷达使用实录" class="headerlink" title="livox-mid70激光雷达使用实录"></a>livox-mid70激光雷达使用实录</h1><p>livox-mid70是由大疆发布的面阵激光雷达，是大疆为自动驾驶推出的一款激光雷达，同时也可用于建立三维地图，文物修复，与大疆无人机相结合使用。你可以在x86和arm架构上都可以使用(arm需要交叉编译)。<br>bilibili上Livox官方发布了大量的视频demo可以去围观一下，同时Livox也有一个论坛可以去看一下。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a class="link"   href="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html" >https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html<i class="fas fa-external-link-alt"></i></a><br>这是中文官方文档，请根据以上文档完成硬件上的连接以及Ip配置，一切以官方文档为主。</p><ul><li>硬件连接</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/one_lidar_connect.png"                                     ></p><ul><li><p>更改IP：一般来说刚拿到手都是<strong>静态IP</strong>，这时候你只需要将网线与你自己笔记本相连，然后通过用户手册查看你自己雷达的IP，那需要设置你自己电脑的IP为手动，并将其分在同一网段不同的地址下：</p><pre><code>  如我的Mid70的IP地址为192.168.1.105，  那么我电脑设置时  IP：192.168.1.104，  子网掩码：255.255.255.0,  网关：192.168.0.1</code></pre></li></ul><p>如果对IP配置有问题,或想改为动态IP详情参见<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Mid%20Series%20User%20Manual%20(CN).pdf" >用户手册<i class="fas fa-external-link-alt"></i></a></p><h2 id="Livox-Viewer"><a href="#Livox-Viewer" class="headerlink" title="Livox Viewer"></a>Livox Viewer</h2><p>Livox Viewer是一款图形化操作的显示软件，有助于快速让你知道你的硬件连接和Ip配置有没有问题。</p><ul><li><a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Viewer%200.8.0.7z" >Livox-Viewer for Windows<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.livoxtech.com/3296f540ecf5458a8829e01cf429798e/downloads/Livox%20Viewer/Livox_Viewr_For_Linux_Ubuntu16.04_x64_0.7.0.tar.gz" >Livox-Viewer for ubuntu16.04<i class="fas fa-external-link-alt"></i></a>,下载后解压运行<code>./livox viewer.sh</code>即可打开如下界面。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/start_Viewer_and_link_Horizon.png"                                     ></li><li>官方软件Livox Viewer仅支持Windows或ubuntu16.04/14.04,所以建议如果不是这两个版本有ros可以直接上。</li></ul><h2 id="Livox-SDK"><a href="#Livox-SDK" class="headerlink" title="Livox-SDK"></a>Livox-SDK</h2><p>刚刚Livox Viewer只是一个快速尝试，如果你要做开发就<strong>必须</strong>要安装Livox-SDK(包括后面要在ros上使用也必须先要安装这个)</p><ul><li><p>github上中文<a class="link"   href="https://github.com/Livox-SDK/Livox-SDK/blob/master/README_CN.md" >README<i class="fas fa-external-link-alt"></i></a></p></li><li><p>先从github上clone下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/Livox-SDK.git</span><br></pre></td></tr></table></figure></li><li><p>再编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Livox-SDK</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>简单运行demo，注意这里的sample是在build文件夹下面的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sample/lidar &amp;&amp; ./lidar_sample</span><br></pre></td></tr></table></figure></li></ul><h2 id="livox-ros-driver"><a href="#livox-ros-driver" class="headerlink" title="livox-ros-driver"></a>livox-ros-driver</h2><p>不得不说ros是真的好用，所以建议在ros下使用，会使得一切都很清晰明了。装<code>livox-ros-driver</code>前必须要先装<code>Livox-SDK</code>。</p><ul><li><p>先从github上clone下来，这里一定要用下面这个命令把它clone到相应位置，否则会出问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src</span><br></pre></td></tr></table></figure></li><li><p>简单的<code>catkin_make</code>一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li><li><p>别忘了添加环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./devel/setup.sh</span><br></pre></td></tr></table></figure></li><li><p>之后跑个rviz的demo，让你的激光雷达点云数据在rviz里显示出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch</span><br></pre></td></tr></table></figure></li></ul><h2 id="录制你的点云数据"><a href="#录制你的点云数据" class="headerlink" title="录制你的点云数据"></a>录制你的点云数据</h2><p>点云数据不像二维图像一样，简简单单录制一个视频就好，作为点云数据记录是比较特殊的。<br>livox一共有两种录制格式</p><h4 id="lvx格式"><a href="#lvx格式" class="headerlink" title="lvx格式"></a>lvx格式</h4><p>lvx格式是livox的一种自定义格式，如果你想在Windows上快速录制，可以<strong>使用Livox Viewer进行录制</strong>，也可以<strong>通过<code>Livox-SDK</code>中的文件录制</strong></p><ul><li>首先进入以下路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./Livox_SDK/build/sample/lidar_lvx_file</span><br></pre></td></tr></table></figure></li><li>然后运行下面这个文件，这里不用<code>-c</code>指定也可以，这里指定了lidar并设定持续10s<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lidar_lvx_sample -c <span class="string">&quot;此处为已连接的Lidar的15位广播码&quot;</span> -t 10</span><br></pre></td></tr></table></figure>通过上面的操作会得到一个<code>.lvx</code>格式的文件，这个文件可以在Livox Viewer中直接播放，也可以转成<strong>rosbag</strong>(一个可以把ros中当前所有topic中message记录下来的东西)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver lvx_to_rosbag.launch lvx_file_path:=<span class="string">&quot;/home/livox/test.lvx&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="rosbag格式"><a href="#rosbag格式" class="headerlink" title="rosbag格式"></a>rosbag格式</h4><p>rosbag是ros中非常好用的一个东西，我在之前的ros文章中有提到过。当我们在运行livox-ros-driver中的rviz显示时，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch <span class="comment">#详情看上面livox-ros-driver</span></span><br></pre></td></tr></table></figure><p>我们可以把此时的所有消息用rosbag记录下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -a -o myrosbag.bag <span class="comment">#-a代表所有的消息,-c代表输出名称</span></span><br></pre></td></tr></table></figure><p>此时就会生成一个.bag文件，具体名称看终端的输出。<br>你可以通过以下命令进行播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -l <span class="comment">#-l代表loop循环播放</span></span><br></pre></td></tr></table></figure><p>此时再打开在livox-ros-driver下的的rviz,就可以得到rosbag中的点云图了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox/src/livox_ros_driver/</span><br><span class="line">rviz -d config/display_lidar_points.rviz <span class="comment">#这种.rviz文件实际上是保存rviz相关显示的数据</span></span><br></pre></td></tr></table></figure><h2 id="livox-detection"><a href="#livox-detection" class="headerlink" title="livox_detection"></a>livox_detection</h2><p>livox_detection指的是激光点云检测，livox官方给的代码可以检测各种车和行人。官方说2080ti下需要50ms。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/demo1.4a7m388oo240.gif"                                     ></p><p>在Livox官方的github仓库中有两个激光点云检测仓库分别为<code>livox_detection</code>和<code>livox_dection_simu</code>。<br>这两个仓库看上去都差不多，但实际上非常坑的是：</p><ul><li><code>livox_detection</code>仓库中的预训练模型在可以识别人和车，但车的识别效果不是很好;</li><li><code>livox_dection_simu</code>仓库中的预训练模型只能识别车，而几乎无法识别到人(虽然代码看上去都差不多)。</li></ul><p>至于原因我也不知道，只是这坑了我一会儿，后来在issue发现了这个问题。</p><p>由于两个仓库操作都非常相似，这里选livox_detection_simu为例。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>python3.6+</li><li>tensorflow1.13+ (tested on 1.13.0)</li><li>pybind11(后面的过程中安装)</li><li>ros</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>首先clone仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_detection_simu</span><br></pre></td></tr></table></figure></li><li><p>然后配置pybind(pybind就是这样，每次都需要clone在那个路径下才行)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> livox_detection_simu/utils/lib_cpp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pybind/pybind11.git</span><br></pre></td></tr></table></figure></li><li><p>编译(在刚刚的<code>lib_cpp</code>路径下)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>把c++得到的依赖文件放到项目根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp lib_cpp.so ../../../</span><br></pre></td></tr></table></figure></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/dataset/livox_detection_simu_model.zip" >预训练模型<i class="fas fa-external-link-alt"></i></a>,会得到model文件夹，把它放在项目根目录下，这样你就不用改模型地址了,</p></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/github/livox_detection_v1.1_data.zip" >rosbag<i class="fas fa-external-link-alt"></i></a>,这是官方提供的rosbag，你也可以自己录一个。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3></li><li><p>打开一个终端运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行rviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rviz -d ./config/show.rviz <span class="comment">#在livox_detection_simu仓库下</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -r 0.1 <span class="comment">#找到你存放rosbag的路径运行，发送消息间隔0.1s</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行目标检测程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python livox_detection_simu.py <span class="comment">#如果你的模型放在其他地方，你需要在config下将其模型路径改为你所放预训练模型的路径</span></span><br></pre></td></tr></table></figure></li></ul><p>由于目标检测速度相当慢，实时性非常差，队列里可能还缓存了很多帧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;a href=&quot;#livox-mid70激光雷达使用实录&quot; class=&quot;headerlink&quot; title=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;/a&gt;livox-mid70激光雷达使用实录&lt;/h1&gt;&lt;p&gt;li</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="lidar" scheme="http://example.com/tags/lidar/"/>
    
  </entry>
  
  <entry>
    <title>在线文本对比</title>
    <link href="http://example.com/2021/11/09/text-compare-md/"/>
    <id>http://example.com/2021/11/09/text-compare-md/</id>
    <published>2021-11-09T05:59:46.000Z</published>
    <updated>2021-11-09T06:03:25.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线文本对比"><a href="#在线文本对比" class="headerlink" title="在线文本对比"></a>在线文本对比</h1><p>推荐一个在线快速对比文本区别的网站：</p><p><a class="link"   href="https://text-compare.com/" >https://text-compare.com/<i class="fas fa-external-link-alt"></i></a></p><p>可能会需要翻墙，但还挺好用。</p><p>不用下载可以直接对比，发个博客留作记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在线文本对比&quot;&gt;&lt;a href=&quot;#在线文本对比&quot; class=&quot;headerlink&quot; title=&quot;在线文本对比&quot;&gt;&lt;/a&gt;在线文本对比&lt;/h1&gt;&lt;p&gt;推荐一个在线快速对比文本区别的网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="website" scheme="http://example.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>ros基本操作</title>
    <link href="http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-02T17:56:47.000Z</published>
    <updated>2021-11-09T05:58:41.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros基本操作"><a href="#ros基本操作" class="headerlink" title="ros基本操作"></a>ros基本操作</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>我们都知道话题机制是ros中必不可少的一个机制，那怎样查看我们所发布的话题呢</p><ul><li>list命令可以看到我们当前总共有哪些topic<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure></li><li>echo命令可以输出指定topic里的消息的内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo cmd_vel #cmd_vel是一个小海龟的速度topic</span><br></pre></td></tr></table></figure></li><li>hz命令可以计算指定topic消息发布的平均速率<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic hz cmd_vel</span><br></pre></td></tr></table></figure></li><li>info命令可以输出topic里的message的数据类型以及发布者接受者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic info cmd_vel</span><br></pre></td></tr></table></figure></li><li>rosmag show可以显示某个数据类型里具体的数据类型结构（注意这个和当前运行的程序没有关系）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg show geometry/Twist </span><br></pre></td></tr></table></figure>上面这个命令显示了geometry/Twist里包含的具体数据结构，如角速度(angular)xyz线速度(linear)xyz，geometry/Twist是cmd_vel这个topic里的消息的数据类型。</li></ul><h2 id="rqt"><a href="#rqt" class="headerlink" title="rqt"></a>rqt</h2><p>rqt是ros里可视化最基础的方式。</p><ul><li>rqt_graph可以显示出整个ros的分布式架构，包括节点，话题，服务等等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure></li><li>rqt_plot可以实时绘制出具体的话题里的消息里的一个或多个数据的变化曲线<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_plot cmd_vel/linear/x cmd_vel/angular/z</span><br></pre></td></tr></table></figure></li></ul><h2 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h2><p>rosbag可以记录消息，还可以重放消息。这对我们调试某个模块非常有帮助。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bagfiles</span><br><span class="line">rosbag record -a</span><br></pre></td></tr></table></figure><p>-a 选项表示将当前发布的所有 topic 数据都录制保存到一个 rosbag 文件中，录制的数据包名字为日期加时间。<br>也可以只记录某些感兴趣的 topic</p><ul><li>想要录制指定topic上的消息，你可以运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record cmd_vel</span><br></pre></td></tr></table></figure></li></ul><p>如果要指定生成数据包的名字，则用-O /-o 参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O filename.bag /topic_name1</span><br></pre></td></tr></table></figure><p>如果在 launch 文件中使用 rosbag record 命令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure><ul><li><p>rosbag info指令可以显示数据包中的信息:        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag info filename.bag</span><br></pre></td></tr></table></figure></li><li><p>rosbag play<br>接下来回放数据包中的 topic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果想改变消息的发布速率，可以用下面的命令，-r 后面的数字对应播放速率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果希望 rosbag 循环播放，可以用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br></pre></td></tr></table></figure><p>如果只播放感兴趣的 topic ，则用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br></pre></td></tr></table></figure><p>在上述播放命令执行期间，空格键可以暂停播放。</p></li></ul><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p>这里我就不写了<br>精品博客：<a class="link"   href="http://ttshun.com/2018/05/24/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8Broslaunch/" >http://ttshun.com/2018/05/24/ROS学习之roslaunch/<i class="fas fa-external-link-alt"></i></a><br>来自励志献身slam的阿翔，里面有很多好的博文都可以去看一看，特别是slam相关的</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>未完待续，这里有一篇 比较详细的代码建议详细看一看：<a class="link"   href="http://ttshun.com/2018/03/22/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%91%BD%E4%BB%A4/" >http://ttshun.com/2018/03/22/ROS学习之基本概念和命令/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros基本操作&quot;&gt;&lt;a href=&quot;#ros基本操作&quot; class=&quot;headerlink&quot; title=&quot;ros基本操作&quot;&gt;&lt;/a&gt;ros基本操作&lt;/h1&gt;&lt;h2 id=&quot;topic&quot;&gt;&lt;a href=&quot;#topic&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>rosserial进行串口通信</title>
    <link href="http://example.com/2021/11/02/rosserial/"/>
    <id>http://example.com/2021/11/02/rosserial/</id>
    <published>2021-11-01T17:56:47.000Z</published>
    <updated>2021-11-02T16:34:56.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rosserial进行串口通信"><a href="#rosserial进行串口通信" class="headerlink" title="rosserial进行串口通信"></a>rosserial进行串口通信</h1><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><ul><li>用于两个模块之间传输数据，是我们最常用的数据通信方式之一。包括单片机之间的通信，单片机与工控机之间的通信，单片机与外设模块之间的通信等等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-11-20.iyynbl97fo8.png"                      style="zoom:80%;"                 ><ul><li>由于 CPU 与接口之间按并行方式传输，接口与外设之间按串行方式传输，因此，在串行接口中，必须要有 “ 接收移位寄存器 “ （串→并）和 “ 发送移位寄存器 “ （并→串）.</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-16-55.67nf1dm75zk0.png"                      style="zoom: 67%;"                 ><ul><li>串口通讯是以高低电平为传输媒介，一位一位的传输，这一点是后面需要时刻牢记的。</li></ul><h3 id="具体发送的过程"><a href="#具体发送的过程" class="headerlink" title="具体发送的过程"></a>具体发送的过程</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-21-41.3wv7h75f5fg0.png"                                     ></p><ul><li><p>波特率：传输速度的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数。如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。</p></li><li><p>数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包的数据位数，标准值是6、7和8位。比如，当我想发送一个uint8的整数，它就刚好能够完整发送。</p></li><li><p>我们只需要记住的是，串口一次只能发送8位二进制数，所以要发送和接受的数据是以8位二进制数的数组存储的，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> buffer[<span class="number">12</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h3><p>那既然我们一次只能发8位数字，那对于float这种32位的数字要怎么发呢？</p><p>答案是把它拆开为4个8位数字发出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">3.5</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f1 = (*((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;(x)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;                <span class="comment">//4个字节的float x转换为buffer中的4位</span></span><br><span class="line">        <span class="keyword">uint8_t</span> tmp = (f1 &gt;&gt; (<span class="number">8</span> * i)) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buffer[i] = tmp;                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看上去拆开的方法显然没有我们想的那么简单。</li><li>我们知道<code>float</code>的数据存储类型是比较复杂的，有尾数幂数等等巴拉巴拉。当我们把其拆分的时候会遇到许多问题，为了更好的运算，我们将其转换为无符号32位整数,即<code>unsigned int</code>。</li><li>仔细看上面的代码<code> unsigned int f1 = (*((unsigned int *)&amp;(x)))</code>，你可能会感觉很疑惑这行代码，但你细看或许就明白了。</li><li>实际上是把x的指针类型强行从<code>float</code>变成<code>unsigned int</code>。这样的好处是其在内存中的值不会变,那个二进制数还是那些，而我们直接使用类型转换实际上会改变其在内存中的值。</li></ul><p>同样再收到消息的时候我们也需要相同的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span> ; i--)&#123;            <span class="comment">//vertical pitch</span></span><br><span class="line">    hor += buffer[i];</span><br><span class="line">    <span class="keyword">if</span>(i) hor &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">yaw = (*((<span class="keyword">float</span>*)&amp;hor));</span><br></pre></td></tr></table></figure><h3 id="Ubuntu中串口通讯"><a href="#Ubuntu中串口通讯" class="headerlink" title="Ubuntu中串口通讯"></a>Ubuntu中串口通讯</h3><p>Ubuntu下的串口助手cutecom可以快速帮你查看是否有串口信号传入你的ubuntu。(虽然我之前并没有用过，使用方法也可以请教电控组成员或自行谷歌，如果不大行就算了吧)</p><ul><li><p>安装cutecom并打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cutecom</span><br><span class="line">sudo cutecom</span><br></pre></td></tr></table></figure></li><li><p>查看连接你电脑的串口信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev | grep ttyU* <span class="comment">#/dev路径下通常包含了所连外设，故要查看串口需要在这里进行查看，而grep是正则化，只查看名字是ttyU开头的文件</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyS* <span class="comment">#网上看到的，不知道行不行</span></span><br></pre></td></tr></table></figure><p>你可以通过拔插串口看哪一个设备改变从而确定设备名称。</p><p>详细的你可以看我随便找的一个链接：<a class="link"   href="https://blog.csdn.net/maizousidemao/article/details/103236666" >https://blog.csdn.net/maizousidemao/article/details/103236666<i class="fas fa-external-link-alt"></i></a></p></li></ul><h4 id="Ros中的串口通讯"><a href="#Ros中的串口通讯" class="headerlink" title="Ros中的串口通讯"></a>Ros中的串口通讯</h4><p>Ros使用rosserial包作为串口通信的方式</p><ol><li>首先下载rosserial</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-serial</span><br></pre></td></tr></table></figure><ul><li>进入安装位置确认是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd serial</span><br></pre></td></tr></table></figure><ul><li>若是成功则能够进入位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/melodic/share/serial</span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后创造工作空间,参照<a class="link"   href="https://blog.csdn.net/liuxiaodong400/article/details/88072502" >这个博客<i class="fas fa-external-link-alt"></i></a></p></li><li><p>创造功能包并编写以下代码</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serial_port.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;serial/serial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;serial_port&quot;</span>);</span><br><span class="line">    <span class="comment">//创建句柄（虽然后面没用到这个句柄，但如果不创建，运行时进程会出错）</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个serial类</span></span><br><span class="line">    serial::Serial sp;</span><br><span class="line">    <span class="comment">//创建timeout</span></span><br><span class="line">    serial::Timeout to = serial::Timeout::<span class="built_in">simpleTimeout</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//设置要打开的串口名称</span></span><br><span class="line">    sp.<span class="built_in">setPort</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>);</span><br><span class="line">    <span class="comment">//设置串口通信的波特率</span></span><br><span class="line">    sp.<span class="built_in">setBaudrate</span>(<span class="number">115200</span>);</span><br><span class="line">    <span class="comment">//串口设置timeout</span></span><br><span class="line">    sp.<span class="built_in">setTimeout</span>(to);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开串口</span></span><br><span class="line">        sp.<span class="built_in">open</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(serial::IOException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR_STREAM</span>(<span class="string">&quot;Unable to open port.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断串口是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(sp.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO_STREAM</span>(<span class="string">&quot;/dev/ttyUSB0 is opened.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取缓冲区内的字节数</span></span><br><span class="line">        <span class="keyword">size_t</span> n = sp.<span class="built_in">available</span>();</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//读出数据</span></span><br><span class="line">            n = sp.<span class="built_in">read</span>(buffer, n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//16进制的方式打印到屏幕</span></span><br><span class="line">                std::cout &lt;&lt; std::hex &lt;&lt; (buffer[i] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//把数据发送回去</span></span><br><span class="line">            sp.<span class="built_in">write</span>(buffer, n);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭串口</span></span><br><span class="line">    sp.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CmakeLists如下:</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(serial_com)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Compile as C++11, supported in ROS Kinetic and newer</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span> <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  OpenCV REQUIRED</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  serial</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Declare a C++ library</span></span><br><span class="line"><span class="comment"># add_library($&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   src/$&#123;PROJECT_NAME&#125;/serial_com.cpp</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(stm_com</span><br><span class="line">  serial_port.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(stm_com <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(stm_com</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>运行roscore，运行节点看是否能打开串口。如果提示Unable to open port，是由于权限不够引起的，进行如下操作<br>创建文件:（若使用的是ttyACM将ttyusb替换即可）</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>udev<span class="regexp">/rules.d/</span><span class="number">70</span>-ttyusb.rules</span><br></pre></td></tr></table></figure><p>在打开的文件中添加</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KERNEL</span>==<span class="string">&quot;ttyUSB[0-9]*&quot;</span>, <span class="type">MODE</span>=<span class="string">&quot;0666&quot;</span></span><br></pre></td></tr></table></figure><p>或者直接更改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/ttyUSB*<span class="comment">#后面这个是你的串口设备</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rosserial进行串口通信&quot;&gt;&lt;a href=&quot;#rosserial进行串口通信&quot; class=&quot;headerlink&quot; title=&quot;rosserial进行串口通信&quot;&gt;&lt;/a&gt;rosserial进行串口通信&lt;/h1&gt;&lt;h2 id=&quot;串口通信&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>从神经网络到深度学习</title>
    <link href="http://example.com/2021/11/02/mlbasic/"/>
    <id>http://example.com/2021/11/02/mlbasic/</id>
    <published>2021-11-01T17:50:00.000Z</published>
    <updated>2021-11-04T10:54:20.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从神经网络到深度学习"><a href="#从神经网络到深度学习" class="headerlink" title="从神经网络到深度学习"></a>从神经网络到深度学习</h1><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在之前我们已经介绍过了一些优化问题，然而并不是所有优化问题从输入到目标函数之间都有明确的公式。不如说，在生活中大部分时候我们都很难建立一个很准确的数学模型，同时也无法得知需要优化什么参数，特别是对于图片分类来说。例如，给你一张图片，让你分辨是猫还是狗。对于输入来说，我们有一张图片rgb三通道的所有值，而需要输出0或1分别代表猫和狗。为了解决这个问题，我们引入神经网络等相关一系列概念。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2020.cnblogs.com/blog/1839046/202012/1839046-20201213200410529-875096804.png"                      alt="猫狗"                ></p><h2 id="机器学习-神经网络-深度学习"><a href="#机器学习-神经网络-深度学习" class="headerlink" title="机器学习 神经网络 深度学习"></a>机器学习 神经网络 深度学习</h2><p>首先，有必要对神经网络、深度学习、机器学习的概念做个简单描述。</p><p>神经网络，该模型灵感来自动物的中枢神经系统，通常呈现为相互连接的“神经元”，它可以对输入值通过反馈机制使得它们适应对应的输出。</p><p>深度学习是神经网络的进阶版，它的基本思路与神经网络类似，但往往比神经网络有着更复杂的结构以及优化算法，是神经网络的纵向延伸，常见的模型有CNN, RNN, LSTM等。</p><p>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>下面的图片很好地描述了这三者之间的关系</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://pic1.zhimg.com/80/v2-6d2584526f458fa512543d04ffb66c42_1440w.jpg?source=1940ef5c"                      alt="区别"                > </p><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><p><a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/1_ML_Basics.pdf" >ML<i class="fas fa-external-link-alt"></i></a></p><h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><p><strong>好的入门博文</strong>：<a class="link"   href="https://www.cnblogs.com/subconscious/p/5058741.html" >神经网络入门<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络实践与理解</strong>：<a class="link"   href="http://playground.tensorflow.org/" >tensorflow游乐场<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络的详细理解</strong>：<a class="link"   href="https://b23.tv/c44LK8" >吴恩达神经网络<i class="fas fa-external-link-alt"></i></a></p><p><strong>自己的板书</strong>:<a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/ml_nn.pdf" >ml_nn<i class="fas fa-external-link-alt"></i></a></p><h2 id="pytorch的相关介绍"><a href="#pytorch的相关介绍" class="headerlink" title="pytorch的相关介绍"></a>pytorch的相关介绍</h2><p>pytorch是python的第三方库，是由facebook开源的神经网络框架，并有专门针对GPU加速模型训练的模块。与tensorflow不同，pytorch编程简洁，接口简单，且速度不逊色于其他框架，是当前神经网络最简洁，高效的实现方法之一。</p><p><strong>好的博文</strong>：<a class="link"   href="https://zhuanlan.zhihu.com/p/265394674?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=907670979105415168" >知乎pytorch<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从神经网络到深度学习&quot;&gt;&lt;a href=&quot;#从神经网络到深度学习&quot; class=&quot;headerlink&quot; title=&quot;从神经网络到深度学习&quot;&gt;&lt;/a&gt;从神经网络到深度学习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="machine leaning" scheme="http://example.com/tags/machine-leaning/"/>
    
  </entry>
  
  <entry>
    <title>sklearn决策树</title>
    <link href="http://example.com/2021/11/02/python-dt/"/>
    <id>http://example.com/2021/11/02/python-dt/</id>
    <published>2021-11-01T17:31:38.000Z</published>
    <updated>2021-11-01T17:34:28.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn决策树"><a href="#sklearn决策树" class="headerlink" title="sklearn决策树"></a>sklearn决策树</h1><h3 id="参数表示"><a href="#参数表示" class="headerlink" title="参数表示"></a>参数表示</h3><p>决策树中有<strong>参数</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DecisionTreeClassifier(criterion=<span class="string">&quot;gini&quot;</span></span><br><span class="line">           , splitter=<span class="string">&quot;best&quot;</span></span><br><span class="line">                    , max_depth=<span class="literal">None</span></span><br><span class="line">                    , min_samples_split=<span class="number">2</span></span><br><span class="line">                    , min_samples_leaf=<span class="number">1</span></span><br><span class="line">                    , min_weight_fraction_leaf=<span class="number">0.</span></span><br><span class="line">                    , max_features=<span class="literal">None</span></span><br><span class="line">                    , random_state=<span class="literal">None</span></span><br><span class="line">                    , max_leaf_nodes=<span class="literal">None</span></span><br><span class="line">                    , min_impurity_decrease=<span class="number">0.</span></span><br><span class="line">                    , min_impurity_split=<span class="literal">None</span></span><br><span class="line">                    , class_weight=<span class="literal">None</span>,</span><br><span class="line">                    presort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>以下几个参数较为重要</p><blockquote><ul><li><strong>criterion</strong> : string, optional (default=”gini”)<br><u>用以设置用信息熵还是基尼系数计算。</u><br>(1).criterion=’gini’,分裂节点时评价准则是Gini指数。<br>(2).criterion=’entropy’,分裂节点时的评价指标是信息增益(模型欠拟合时使用)。</li><li><strong>max_depth</strong> : int or None, optional (default=None)。<br><u>指定树的最大深度</u>。 如果为None，表示树的深度不限。直到所有的叶子节点都是纯净的，即叶子节点 中所有的样本点都属于同一个类别。或者每个叶子节点包含的样本数小于min_samples_split。</li><li><strong>splitter</strong> : string, optional (default=”best”)。<br><u> 指定分裂节点时的策略。 </u><br>(1).splitter=’best’,表示选择最优的分裂策略。<br>(2).splitter=’random’,表示选择最好的随机切分策略。</li><li><strong>min_samples_leaf</strong> : int, float, optional (default=1)<br><u> 限定每个节点分枝后子节点至少有多少个数据，否则就不分枝</u>。<br>(1).如果为整数，则min_samples_split就是最少样本数。<br>(2).如果为浮点数(0到1之间)，则每个叶子节点最少样本数为ceil(min_samples_leaf * n_samples)</li></ul></blockquote><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在编写代码时，对数据的预处理主要包括对数据的<strong>导入</strong>，<strong>补全</strong>与<strong>删减</strong>，<strong>x与y的选取</strong>，将<strong>字典变量转化为虚拟变量</strong>等</p><ol><li><strong>导入数据</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier </span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridsearchCV</span><br><span class="line">data = pd.read_csv(<span class="string">&quot;your_ducument&quot;</span>)</span><br><span class="line"><span class="comment">#查看数据信息</span></span><br><span class="line">data.info()</span><br><span class="line"><span class="comment">#显示表的前10行</span></span><br><span class="line">data.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><strong>删除特征</strong><br>对于一些不需要的特征，例如<u>明显与因变量关系不大的特征</u>或是<u>缺失值实在太多难以填补的特征</u>可以适当性的直接拿掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">&quot;被拿掉的特征名1，被拿掉特征名2&quot;</span>], inplace = <span class="literal">True</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>inplace = True</code>指的是将替换原有的data,即等价于<code>data = data.drop([&quot;被拿掉的特诊名1，被拿掉特诊名2&quot;],axis = 1)</code>。<br>关于<code>axis = 1</code>,只的是对<strong>列</strong>操作，即对<strong>每一行</strong>操作.</p></blockquote><ol start="3"><li><strong>填充缺失值</strong><br>假设我们有一特征为年龄(age)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用平均值来填补缺失值</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].fillna(data[<span class="string">&quot;age&quot;</span>].mean())</span><br></pre></td></tr></table></figure>当某特征仅缺失较少的值时，把缺失的那个数据所在行删掉即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认有axis = 0,即对整行进行操作</span></span><br><span class="line">data = data.dropna()</span><br></pre></td></tr></table></figure></li><li><strong>类型转换</strong><br>假设我们有一特征<u>楼层(floor)</u>：有first，second，third 三个string值，将其转化为0，1，2。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以得到[&quot;first&quot;,&quot;second&quot;,third]</span></span><br><span class="line">labels = data[<span class="string">&quot;floor&quot;</span>].unique().tolist()</span><br><span class="line"><span class="comment">#index可以返回元素x在列表中的位置</span></span><br><span class="line">data[<span class="string">&quot;floor&quot;</span>] = data[<span class="string">&quot;floor&quot;</span>].apply( <span class="keyword">lambda</span> x : labels.index(x))</span><br></pre></td></tr></table></figure><blockquote><ul><li>关于apply()的具体用法<a class="link"   href="https://blog.csdn.net/anshuai_aw1/article/details/82347016" >见此<i class="fas fa-external-link-alt"></i></a></li></ul></blockquote></li><li><strong>语法补充</strong><br>上述我们一直在使用的<strong>data</strong>是pandas特有的<strong>DataFrame</strong>类型，关于取出其中的某一列特征进行操作可以使用<code>data[&quot;age&quot;]</code>，但最好使用<code>data.loc[:,&quot;age&quot;]</code>或是<code>data.iloc[:,3]</code>。</li></ol><h3 id="分离特征-x-与标签-y"><a href="#分离特征-x-与标签-y" class="headerlink" title="分离特征(x)与标签(y)"></a>分离特征(x)与标签(y)</h3><p>假设我们要取出的标签是<u>楼层(floor)</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = data.iloc[:, data.colums !=<span class="string">&quot;floor&quot;</span>]</span><br><span class="line">y = data.iloc[:, data.colums == <span class="string">&quot;floor&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="划分训练集与测试集"><a href="#划分训练集与测试集" class="headerlink" title="划分训练集与测试集"></a>划分训练集与测试集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取30%为测试集，70%为训练集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtext, Ytrain, Ytest = train_test_split(x, y, test_size = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>此函数随机选取训练集与测试集，会将索引打乱，为了以防万一对后续造成额外影响，有必要纠正索引.</p><blockquote><ul><li>所谓”索引“，是pandas在导入时DataFrame对每一行数据按顺序产生的索引,当输入<code>Xtrain.index</code>时会返回被打乱的索引列表。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#恢复索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [Xtrain, Xtext, Ytrain, Ytest] ： </span><br><span class="line">    i.index = <span class="built_in">range</span>(i.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(random_state = <span class="number">25</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)<span class="comment">#R方</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li><strong>交叉验证</strong> : 指不断随机改变训练集与测试集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10次交叉验证均值</span></span><br><span class="line">cross_score = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br></pre></td></tr></table></figure></li></ul><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><ul><li><strong>基础方法</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tr = []<span class="comment">#训练集拟合程度</span></span><br><span class="line">te = []<span class="comment">#测试集拟合程度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) : </span><br><span class="line"><span class="comment">#调整max_depth，即剪枝</span></span><br><span class="line">    clf = DecisionTreeClassifier(random_state = <span class="number">25</span>, max_depth = i + <span class="number">1</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">    clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">    score_tr = clf.score(Xtest, Ytest)</span><br><span class="line">    score_te = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br><span class="line">    tr.append(score_tr)</span><br><span class="line">    te.append(score_te)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), tr, color = <span class="string">&quot;red&quot;</span>, label = <span class="string">&quot;train&quot;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), te, color = <span class="string">&quot;blue&quot;</span>,label = <span class="string">&quot;test&quot;</span>)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.legend()</span><br><span class="line">ply.show()</span><br></pre></td></tr></table></figure></li><li><strong>网格搜索</strong><br>事实上就是暴力枚举，速度特别慢<br><del>(而且算了半天说不定还没一开始简简单单的好)</del><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parameters = &#123;<span class="string">&quot;criterion&quot;</span>:(<span class="string">&quot;gini&quot;</span>,<span class="string">&quot;entropy&quot;</span>), </span><br><span class="line">                        <span class="string">&quot;spliter&quot;</span>:(<span class="string">&quot;best&quot;</span>,<span class="string">&quot;random&quot;</span>),</span><br><span class="line">                        <span class="string">&quot;max_depth&quot;</span>: [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)],</span><br><span class="line">                        <span class="string">&quot;min_samples_leaf&quot;</span> = [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>,<span class="number">5</span>)],</span><br><span class="line">                        <span class="string">&quot;min_impurity_decrease&quot;</span> = np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">50</span>) &#125;</span><br><span class="line">clf = DecisionTreeClassifier(random = <span class="number">25</span>)</span><br><span class="line">GS = GridSearchCV(clf, parameters, cv = <span class="number">10</span>)</span><br><span class="line">GS = GS.fit(Xtrain, Ytrain)</span><br><span class="line">GS.best_params_<span class="comment">#最佳参数组合</span></span><br><span class="line">GS.best_score_<span class="comment">#最佳结果r方</span></span><br></pre></td></tr></table></figure><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3>生成可视化图,在这里仅仅只能输出一个dot文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot_data = export_graphviz(tree,out_file= <span class="string">&quot;result.dot&quot;</span>,class_names[<span class="string">&#x27;serious&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>],feature_names=cancer.feature_names,impurity=<span class="literal">False</span>,filled=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>将.dot文件转为jpg文件，展示可视化图(不知道为啥不可用，要用cmd来转换 <code>dot result.dot -T jpg -o result.jpg)</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(graph,)= pydot.graph_from_dot_file(<span class="string">&#x27;result.dot&#x27;</span>)</span><br><span class="line">graph.write_png(<span class="string">&#x27;tree.png&#x27;</span>)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210125183759997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn决策树&quot;&gt;&lt;a href=&quot;#sklearn决策树&quot; class=&quot;headerlink&quot; title=&quot;sklearn决策树&quot;&gt;&lt;/a&gt;sklearn决策树&lt;/h1&gt;&lt;h3 id=&quot;参数表示&quot;&gt;&lt;a href=&quot;#参数表示&quot; class=&quot;head</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklean" scheme="http://example.com/tags/sklean/"/>
    
    <category term="决策树" scheme="http://example.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(6)PairGrid</title>
    <link href="http://example.com/2021/11/02/seaborn6/"/>
    <id>http://example.com/2021/11/02/seaborn6/</id>
    <published>2021-11-01T17:27:36.000Z</published>
    <updated>2021-11-01T17:29:25.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-6-PairGrid"><a href="#seaborn入门-6-PairGrid" class="headerlink" title="seaborn入门(6)PairGrid"></a>seaborn入门(6)PairGrid</h1><h2 id="PairGrid"><a href="#PairGrid" class="headerlink" title="PairGrid"></a>PairGrid</h2><p>代码和图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">iris_g = sns.PairGrid(iris,hue = <span class="string">&quot;species&quot;</span>)</span><br><span class="line">iris_g.<span class="built_in">map</span>(plt.scatter)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130001248178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>累了，溜了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-6-PairGrid&quot;&gt;&lt;a href=&quot;#seaborn入门-6-PairGrid&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(6)PairGrid&quot;&gt;&lt;/a&gt;seaborn入门(6)PairGrid&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(5)群图(cluster map)</title>
    <link href="http://example.com/2021/11/02/seaborn5/"/>
    <id>http://example.com/2021/11/02/seaborn5/</id>
    <published>2021-11-01T17:25:33.000Z</published>
    <updated>2021-11-01T17:27:18.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-5-群图-cluster-map"><a href="#seaborn入门-5-群图-cluster-map" class="headerlink" title="seaborn入门(5)群图(cluster map)"></a>seaborn入门(5)群图(cluster map)</h1><h2 id="群图-cluster-map"><a href="#群图-cluster-map" class="headerlink" title="群图(cluster map)"></a>群图(cluster map)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">species = iris.pop(<span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(species)</span><br><span class="line">sns.clustermap(iris)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129233342616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>这图可能有亿点点复杂，但其实很简单(<del>并不是</del>)<br>这就是所谓的<strong>分层聚类热图</strong>，首先计算了点与点之间的距离，最接近的会被加入，然后开始比较行与列之间的关系。（<del>说了个几把</del> ）</p><p><strong>让我们稍微换一个简单一点点的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">sns.clustermap(flights,cmap = <span class="string">&quot;Blues&quot;</span>, standard_scale=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>flights代表的是一个二维数组，代表某年某月的乘客人数，<a class="link"   href="https://blog.csdn.net/newsunson/article/details/113408300" >详情见<i class="fas fa-external-link-alt"></i></a></p><p>所以我们得到下面的图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129234934427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>你会发现年份和月份并不是按着顺序排列的，这其实就是一个相当于聚类的过程，你可以把他看成一个聚类后的热力图（<strong>我以为我懂了，仔细一想我好像还是有点懵，希望大佬们来补充一下</strong>）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-5-群图-cluster-map&quot;&gt;&lt;a href=&quot;#seaborn入门-5-群图-cluster-map&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(5)群图(cluster map)&quot;&gt;&lt;/a&gt;seaborn</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(4)关联系数矩阵和热力图</title>
    <link href="http://example.com/2021/11/02/seaborn4/"/>
    <id>http://example.com/2021/11/02/seaborn4/</id>
    <published>2021-11-01T17:24:29.000Z</published>
    <updated>2021-11-01T17:26:51.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-4-关联系数矩阵和热力图"><a href="#seaborn入门-4-关联系数矩阵和热力图" class="headerlink" title="seaborn入门(4)关联系数矩阵和热力图"></a>seaborn入门(4)关联系数矩阵和热力图</h1><h2 id="关联系数矩阵"><a href="#关联系数矩阵" class="headerlink" title="关联系数矩阵"></a>关联系数矩阵</h2><p>这个懂的都懂，大概就是表示两个变量之间的关联性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">tips_mx = tips_df.corr()</span><br><span class="line"><span class="built_in">print</span>(tips_df.corr())</span><br></pre></td></tr></table></figure><p>载入数据有问题看seaborn入门(1)<br>得到如下结果<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230000142.png#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h2><p>我们可以将上面的矩阵可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.heatmap(tips_mx,annot = <span class="literal">True</span> , cmap = <span class="string">&#x27;Blues&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>其中cmap的选择和<a class="link"   href="https://editor.csdn.net/md/?articleId=113408019" >调色盘<i class="fas fa-external-link-alt"></i></a>一样</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230758969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="酷酷的热力图"><a href="#酷酷的热力图" class="headerlink" title="酷酷的热力图"></a>酷酷的热力图</h2><p>我们采用新的数据，并创建一个数据透视图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(name=<span class="string">&#x27;flights&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line"><span class="comment">#数据透视图创建</span></span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原来的数据是这样的<img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232036805.png#pic_center"                      alt="在这里插入图片描述"                ><br>数据透视图是这样的，表示某年某月某日乘坐飞机的人数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129231848465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>画成热力图就是<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232302523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br><del>有种马赛克的美感</del> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-4-关联系数矩阵和热力图&quot;&gt;&lt;a href=&quot;#seaborn入门-4-关联系数矩阵和热力图&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(4)关联系数矩阵和热力图&quot;&gt;&lt;/a&gt;seaborn入门(4)关联系数矩阵和热</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(3)调色盘</title>
    <link href="http://example.com/2021/11/02/seaborn3/"/>
    <id>http://example.com/2021/11/02/seaborn3/</id>
    <published>2021-11-01T17:22:20.000Z</published>
    <updated>2021-11-01T17:25:19.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-3-调色盘"><a href="#seaborn入门-3-调色盘" class="headerlink" title="seaborn入门(3)调色盘"></a>seaborn入门(3)调色盘</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><p>续接上文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">sns.set_context(<span class="string">&#x27;talk&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="调色盘"><a href="#调色盘" class="headerlink" title="调色盘"></a>调色盘</h2><p>访问这个界面你能看到调色看给你的一些风格样式<br><code>https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html</code><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129224410260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>例如我选一个夏天风情的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df,jitter = <span class="literal">True</span>,hue = <span class="string">&#x27;sex&#x27;</span>,palette = <span class="string">&#x27;summer&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129225343154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-3-调色盘&quot;&gt;&lt;a href=&quot;#seaborn入门-3-调色盘&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(3)调色盘&quot;&gt;&lt;/a&gt;seaborn入门(3)调色盘&lt;/h1&gt;&lt;h2 id=&quot;基础准备&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(2)继续展示seaborn的各种绘图效果</title>
    <link href="http://example.com/2021/11/02/seaborn2/"/>
    <id>http://example.com/2021/11/02/seaborn2/</id>
    <published>2021-11-01T17:17:55.000Z</published>
    <updated>2021-11-01T17:21:44.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-2"><a href="#seaborn入门-2" class="headerlink" title="seaborn入门(2)"></a>seaborn入门(2)</h1><h2 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h2><p>续接上文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置风格"><a href="#设置风格" class="headerlink" title="设置风格"></a>设置风格</h2><p>共有4种风格可以选，分别是”white”, “dark”, “whitegrid”, “darkgrid”, “ticks”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&quot;dark&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="简单设置图中元素"><a href="#简单设置图中元素" class="headerlink" title="简单设置图中元素"></a>简单设置图中元素</h2><ul><li>设置画布大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><ul><li>设置字体</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(<span class="string">&#x27;paper&#x27;</span>,font_scale=<span class="number">1.4</span>) </span><br></pre></td></tr></table></figure><blockquote><p>其中’paper’为风格，还有talk,poster等风格</p></blockquote><ul><li>设置坐标轴<br>例如下面的代码是删除左边的坐标轴，同理还可以设置<code>bottom = True</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.despine(left = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>男性女性给的小费差异，默认来看是通过男性给小费的平均值和女性给小费的平均值来进行比较，也可以通过中位数<code>estimator = np.media</code>，标准差<code>np.std</code>，协方差<code>np.cov来估计</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x = <span class="string">&#x27;sex&#x27;</span>, y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, estimator=np.mean)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129203730986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="计数图"><a href="#计数图" class="headerlink" title="计数图"></a>计数图</h2><p>与之相比，计数图可以对某个数据集统计数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(x = <span class="string">&#x27;sex&#x27;</span>, data = tips_df)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221529262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h2><p>这种图不是很懂啊，希望有大佬来分析以下QwQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, hue = <span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221720323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h2><p>同上，感觉这图有点骚,大概就是代表数据的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, hue = <span class="string">&#x27;sex&#x27;</span>,split = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221827101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="剥离图"><a href="#剥离图" class="headerlink" title="剥离图"></a>剥离图</h2><p>这是一个代表不同数据点的散点图，其中一个变量是分类变量，代表着数据的平均分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df,jitter = <span class="literal">True</span>,)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129222746989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="分簇散点图"><a href="#分簇散点图" class="headerlink" title="分簇散点图"></a>分簇散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x  = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df)</span><br></pre></td></tr></table></figure><p>算是小提琴图的点状形式吧<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129223303445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-2&quot;&gt;&lt;a href=&quot;#seaborn入门-2&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(2)&quot;&gt;&lt;/a&gt;seaborn入门(2)&lt;/h1&gt;&lt;h2 id=&quot;准备数据集&quot;&gt;&lt;a href=&quot;#准备数据集&quot; cla</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(1)展示seaborn的各种绘图效果</title>
    <link href="http://example.com/2021/11/02/seaborn1/"/>
    <id>http://example.com/2021/11/02/seaborn1/</id>
    <published>2021-11-01T17:13:33.000Z</published>
    <updated>2021-11-01T17:19:10.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-1-展示seaborn的各种绘图效果"><a href="#seaborn入门-1-展示seaborn的各种绘图效果" class="headerlink" title="seaborn入门(1)展示seaborn的各种绘图效果"></a>seaborn入门(1)展示seaborn的各种绘图效果</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="载入数据集"><a href="#载入数据集" class="headerlink" title="载入数据集"></a>载入数据集</h2><p>以下代码可以查看seaborn自带的数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sns.get_dataset_names())</span><br></pre></td></tr></table></figure><p>这里使用<strong>车祸信息</strong>作为原始数据集,按理来说下面代码就可以实现导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash_df = sns.load_dataset(<span class="string">&quot;car_crashes&quot;</span>)</span><br></pre></td></tr></table></figure><p>但实际上，由于不可描述的某种抗力，导致在下载数据集的时候有可能下载不出来(<del>如果你加载出来了当我没说</del>)，所以<strong>需要到github上提前下载数据集</strong>(<a class="link"   href="https://github.com/mwaskom/seaborn-data" >https://github.com/mwaskom/seaborn-data<i class="fas fa-external-link-alt"></i></a>)<u>(建议先导入码云之后再下载)</u>，下载之后将数据集放入与文件相同的目录下，然后使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash_df = sns.load_dataset(name=<span class="string">&quot;car_crashes&quot;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在可以查看表的内容了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(crash_df.head())</span><br></pre></td></tr></table></figure><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>首先，选择你的风格,分别是”white”, “dark”, “whitegrid”, “darkgrid”, “ticks”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&#x27;white&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="简单展示几种绘图方式"><a href="#简单展示几种绘图方式" class="headerlink" title="简单展示几种绘图方式"></a>简单展示几种绘图方式</h3><h4 id="displot"><a href="#displot" class="headerlink" title="displot()"></a>displot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(crash_df[<span class="string">&#x27;not_distracted&#x27;</span>],kde = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195444571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="kdeplot"><a href="#kdeplot" class="headerlink" title="kdeplot()"></a>kdeplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(crash_df[<span class="string">&#x27;speeding&#x27;</span>],crash_df[<span class="string">&#x27;alcohol&#x27;</span>], data = crash_df, shade = </span><br><span class="line"><span class="literal">True</span> ,cbar=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195527693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="jointplot"><a href="#jointplot" class="headerlink" title="jointplot()"></a>jointplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x = <span class="string">&#x27;speeding&#x27;</span>, y = <span class="string">&#x27;alcohol&#x27;</span>, data = crash_df,kind = <span class="string">&#x27;kde&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195543526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="pairplot"><a href="#pairplot" class="headerlink" title="pairplot()"></a>pairplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(crash_df)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195640960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>或者可以使用<strong>hue</strong>分类<u>（这里重新导入了一个数据集）</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborndata&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tips_df.head())</span><br><span class="line">sns.pairplot(tips_df, hue = <span class="string">&#x27;sex&#x27;</span>,)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195651651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="rugplot"><a href="#rugplot" class="headerlink" title="rugplot()"></a>rugplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里用的是上面刚刚载入的数据集</span></span><br><span class="line">sns.rugplot(tips_df[<span class="string">&#x27;tip&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195702475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-1-展示seaborn的各种绘图效果&quot;&gt;&lt;a href=&quot;#seaborn入门-1-展示seaborn的各种绘图效果&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(1)展示seaborn的各种绘图效果&quot;&gt;&lt;/a&gt;se</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>sklearn随机森林</title>
    <link href="http://example.com/2021/11/02/python-rdf/"/>
    <id>http://example.com/2021/11/02/python-rdf/</id>
    <published>2021-11-01T17:11:37.000Z</published>
    <updated>2021-11-01T17:15:51.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn随机森林"><a href="#sklearn随机森林" class="headerlink" title="sklearn随机森林"></a>sklearn随机森林</h1><p>本文基于菜菜的sklearn教学</p><p>@[toc]</p><h2 id="随机森林分类器"><a href="#随机森林分类器" class="headerlink" title="随机森林分类器"></a>随机森林分类器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随机森林是一种集成算法，即运用大量不同的算法，选出最优的一个，主要是基于决策树。</p><h3 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wine = load_wine()</span><br><span class="line"><span class="built_in">print</span>(wine.data.shape)</span><br><span class="line"><span class="built_in">print</span>(wine.target)</span><br></pre></td></tr></table></figure><h3 id="划分测试集和训练集"><a href="#划分测试集和训练集" class="headerlink" title="划分测试集和训练集"></a>划分测试集和训练集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain,Xtest,Ytrain,Ytest = train_test_split(wine.data,wine.target,test_size = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rfc = RandomForestClassifier(random_state = <span class="number">0</span>)</span><br><span class="line">rfc = rfc.fit(Xtrain,Ytrain)</span><br><span class="line">score_r = rfc.score(Xtest,Ytest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random Forest:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(score_r))</span><br></pre></td></tr></table></figure><p>和决策树几乎一模一样，核心代码似乎也就这么几行：</p><ul><li>建立分类器rfc</li><li>带入数据进行训练</li><li>利用测试集给出评分</li></ul><h3 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h3><p>可以输出模型中每一个特征的重要性程度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rfc.feature_importances_)</span><br></pre></td></tr></table></figure><p>下面是这么多次交叉验证之后所得到的准确率变化</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>Xtest可以换成所需要预测的数据，返回对应的标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfc.predict(Xtest)</span><br></pre></td></tr></table></figure><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>交叉验证就是不断的重新划分训练集和数据集进行验证，注意交叉验证的时候是不用<code>fit()</code>的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">rfc = RandomForestClassifier(n_estimators = <span class="number">25</span>)</span><br><span class="line">rfc_s = cross_val_score(rfc,wine.data,wine.target,cv = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), rfc_s,label = <span class="string">&quot;RandomForest&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下面给出十次交叉验证的得分<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130190153741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h3 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a>参数讲解</h3><p>随机森林中的参数大多数与决策树中的参数差不多，最重要的是：</p><ul><li>n_estimator 森林中树中的个数，显然个数越多结果越准确。<br>其他的建议<a class="link"   href="https://blog.csdn.net/u011301133/article/details/52562874" >看这位大佬的<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="随机森林回归"><a href="#随机森林回归" class="headerlink" title="随机森林回归"></a>随机森林回归</h2><p>分类和回归的区别其实就是一个变量是分类变量，一个变量是连续变量。对于sklearn来说几乎没什么区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line">boston = load_boston()</span><br><span class="line">reg = RandomForestRegressor(n_estimators = <span class="number">100</span>,random_state = <span class="number">0</span>)</span><br><span class="line">cross_val_score(reg, boston.data, boston.target, cv = <span class="number">10</span> ,scoring = <span class="string">&quot;neg_mean_squared_error&quot;</span>)</span><br></pre></td></tr></table></figure><p>其他都和分类树一样</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><strong>随机森林在乳腺癌数据上的调参</strong></p><h3 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h3><p>下面调用了乳腺癌患者的例子，给出10次交叉验证的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = load_breast_cancer()</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier(n_estimators=<span class="number">100</span>,random_state=<span class="number">90</span>)</span><br><span class="line">score_pre = cross_val_score(rfc,data.data,data.target,cv=<span class="number">10</span>).mean()</span><br><span class="line"><span class="built_in">print</span>(score_pre)</span><br></pre></td></tr></table></figure><p>最后结果为<code>0.9648809523809524</code>，还是比较准确的</p><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>但是我还是不满意，于是我使用了200次循环，每次循环取十次交叉验证的平均值，并逐次增加树的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = load_breast_cancer()</span><br><span class="line"></span><br><span class="line">scorel = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">200</span>,<span class="number">10</span>):</span><br><span class="line">    rfc = RandomForestClassifier(n_estimators=i+<span class="number">1</span>,n_jobs=-<span class="number">1</span>,random_state=<span class="number">90</span>)</span><br><span class="line">    score = cross_val_score(rfc,data.data,data.target,cv=<span class="number">10</span>).mean()</span><br><span class="line">    scorel.append(score)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(scorel),(scorel.index(<span class="built_in">max</span>(scorel))*<span class="number">10</span>)+<span class="number">1</span>)</span><br><span class="line">plt.figure(figsize=[<span class="number">20</span>,<span class="number">5</span>])</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">201</span>,<span class="number">10</span>),scorel)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果有<img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130190141256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>菜菜后面还写了一堆调参的，但对我一个只打一打美赛的菜鸡好像其实用不到这么多，感兴趣的自己去b站搜菜菜的sklearn吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn随机森林&quot;&gt;&lt;a href=&quot;#sklearn随机森林&quot; class=&quot;headerlink&quot; title=&quot;sklearn随机森林&quot;&gt;&lt;/a&gt;sklearn随机森林&lt;/h1&gt;&lt;p&gt;本文基于菜菜的sklearn教学&lt;/p&gt;
&lt;p&gt;@[toc]&lt;/p&gt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="rdf" scheme="http://example.com/tags/rdf/"/>
    
  </entry>
  
  <entry>
    <title>sklearn数据预处理和特征工程</title>
    <link href="http://example.com/2021/11/02/python-data-process/"/>
    <id>http://example.com/2021/11/02/python-data-process/</id>
    <published>2021-11-01T17:09:17.000Z</published>
    <updated>2021-11-01T17:16:02.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn数据预处理和特征工程"><a href="#sklearn数据预处理和特征工程" class="headerlink" title="sklearn数据预处理和特征工程"></a>sklearn数据预处理和特征工程</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="数据的无量纲化"><a href="#数据的无量纲化" class="headerlink" title="数据的无量纲化"></a>数据的无量纲化</h3><p>一般来说，当我们将数据导入模型的时候，无量纲化的可以帮我们<strong>去除量纲对模型</strong>的影响（决策树和随机森林不需要这样做，它可以处理大多数数据）<br>一般来说线性的无量纲化包括<strong>去中心化</strong>和<strong>缩放处理</strong>，中心化就是将原本的数据通过加减一个固定值使他进行平移，缩放就是对数据乘除一个固定值使其处于某一种范围之中，例如取对数。</p><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p><strong>归一化处理</strong>，可以将数据缩放到0-1之间<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130213325246.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>上面这个肯定会很眼熟,代码实现还是老三样</p><ul><li>实例化</li><li>用<code>fit()</code>处理数据</li><li>导出结果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = MinMaxScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler = scaler.fit(data) <span class="comment">#fit，在这里本质是生成min(x)和max(x)</span></span><br><span class="line">result = scaler.transform(data) <span class="comment">#导出结果</span></span><br></pre></td></tr></table></figure>或者也可以一步到位<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_ = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure>或者你也可以将数据归一化到其他范围<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scaler = MinMaxScaler(feature_range=</span><br><span class="line">[<span class="number">5</span>,<span class="number">10</span>])</span><br><span class="line">result = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4></li></ul><p><strong>标准化处理</strong>可以将数据缩放到-1-1之间<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/2021013021334539.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = StandardScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler.fit(data) <span class="comment">#fit，本质是生成均值和方差</span></span><br><span class="line">scaler.mean_ <span class="comment">#查看均值</span></span><br><span class="line">scaler.var_ <span class="comment">#查看方差_</span></span><br><span class="line">x_std = scaler.transform(data)</span><br></pre></td></tr></table></figure><h4 id="标准化和归一化如何选择"><a href="#标准化和归一化如何选择" class="headerlink" title="标准化和归一化如何选择"></a>标准化和归一化如何选择</h4><p>在大多数机器学习里都是选择<strong>标准化</strong>来进行特征缩放的。<br>而归一化对于异常值较为敏感，优点是便于计算，可以用在图像处理等方面。</p><h3 id="填补缺失值"><a href="#填补缺失值" class="headerlink" title="填补缺失值"></a>填补缺失值</h3><p>首先导入菜菜给的泰坦尼克号数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">r&quot;D:\2 菜菜的sklearn直播课件\预处理数据\Narrativedata.csv&quot;</span>,index_col= <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130212959298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age = data.loc[: ,<span class="string">&quot;Age&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>data</code>是pandas的DataFrame结构</li><li><code>data.loc[: ,&quot;Age&quot;]</code>是Age所在行，是一个字典形式的量，即索引对应年龄</li><li><code>data.loc[: ,&quot;Age&quot;].values</code>取出了字典中所有值,即取出所有年龄，是一个一维数组</li><li><code>data.loc[: ,&quot;Age&quot;].values.reshape(-1,1)</code>将其转化二维列向量，<code>reshape(a,b)</code>指的是转化为a行b列的二维向量，其中-1代表自动计算。</li></ul></blockquote><p>依然是</p><ul><li>实例化<code>SimpleImputer()</code></li><li><code>result = fit_transform(yourdata)</code></li><li><code>data.loc[:&quot;Age&quot;] = result</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imp_mean = SimpleImputer() <span class="comment">#实例化，默认均值填补</span></span><br><span class="line">imp_median = SimpleImputer(strategy=<span class="string">&quot;median&quot;</span>) <span class="comment">#用中位数填补</span></span><br><span class="line">imp_0 = SimpleImputer(strategy=<span class="string">&quot;constant&quot;</span>,fill_value=<span class="number">0</span>) <span class="comment">#用0补</span></span><br><span class="line"></span><br><span class="line">imp_mean = imp_mean.fit_transform(Age)</span><br><span class="line">imp_median = imp_median.fit_transform(Age)</span><br><span class="line">imp_0 = imp_0.fit_transform(Age)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在这里我们使用中位数填补Age</span></span><br><span class="line">data.loc[:,<span class="string">&quot;Age&quot;</span>] = imp_median</span><br><span class="line">data.info()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用众数填补Embarked</span></span><br><span class="line">Embarked = data.loc[:,<span class="string">&quot;Embarked&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">imp_mode = SimpleImputer(strategy =<span class="string">&quot;most_frequent&quot;</span>)</span><br><span class="line">data.loc[:,<span class="string">&quot;Embarked&quot;</span>] = imp_mode.fit_transform(Embarked)</span><br><span class="line">data.info()</span><br></pre></td></tr></table></figure><code>data.loc[:,&quot;Age&quot;] = imp_median</code>这里是可以直接赋值的，虽然他两类型不同,一个是字典一个是二维数组<br>也可以<strong>直接用pands和numpy填补</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:,<span class="string">&quot;Age&quot;</span>] = data.loc[:,<span class="string">&quot;Age&quot;</span>].fillna(data.loc[:,<span class="string">&quot;Age&quot;</span>].median())</span><br></pre></td></tr></table></figure>也可以直接将缺失的数据丢掉<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.dropna(axis=</span><br><span class="line"><span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><code>axis = 0</code>代表对行操作，<code>inplace = True</code>代表直接对原数据替换<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3>其实就是将<strong>文字型变量转化为数值型</strong><br>依然是三步：</li><li>实例化<code>LabelEncoder()</code></li><li><code>le.fit_transform(data.iloc[:,2])</code></li><li><code>data.iloc[:,2] = result</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">result = le.fit_transform(data.iloc[:,<span class="number">2</span>])</span><br><span class="line">data.iloc[:,<span class="number">2</span>] = result</span><br></pre></td></tr></table></figure><h3 id="二值化和分段"><a href="#二值化和分段" class="headerlink" title="二值化和分段"></a>二值化和分段</h3><h4 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h4><p>例如我们可以将上述数据二值化，大于30岁的赋值为1，小于30岁的赋值为0<br>嘿嘿，老三样，只是这次又得转为二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line">X = data2.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">bn = Binarizer(threshold = <span class="number">30</span>)</span><br><span class="line">result = bn.fit_transform(X)</span><br></pre></td></tr></table></figure><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>这次KBinsDiscretizer()里面有几个重要参数</p><ul><li><strong>n_bins</strong>是分的类的数量</li><li><strong>encode</strong>是编码方式，’ordinary’,指的是返回一个整数，如分成三个类返回0，1，2构成的数列</li><li><strong>strategy</strong>有三种”uniform”是等宽分类，用最大值与最小值之差除与类的数量作为每个类的宽度,”quantile”是将每个类中的样本数分的都相同,“kmeans”是用kmeans聚类的方法来分类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> KBinsDiscretizer</span><br><span class="line">X = data.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line">est = KBinsDiscretizer(n_bins=<span class="number">3</span>, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">est.fit_transform(X) </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn数据预处理和特征工程&quot;&gt;&lt;a href=&quot;#sklearn数据预处理和特征工程&quot; class=&quot;headerlink&quot; title=&quot;sklearn数据预处理和特征工程&quot;&gt;&lt;/a&gt;sklearn数据预处理和特征工程&lt;/h1&gt;&lt;h2 id=&quot;数据预处理</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>sklearn主成分分析PCA</title>
    <link href="http://example.com/2021/11/02/python-pca/"/>
    <id>http://example.com/2021/11/02/python-pca/</id>
    <published>2021-11-01T17:00:55.000Z</published>
    <updated>2021-11-01T17:07:21.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn主成分分析PCA"><a href="#sklearn主成分分析PCA" class="headerlink" title="sklearn主成分分析PCA"></a>sklearn主成分分析PCA</h1><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>给数学基础不是很好的看<br>PCA主要用于<strong>降维</strong>，比如一个人有<strong>身高，年龄，样貌，性别，智力，耐力，速度，成绩</strong>等等很多<strong>特征</strong>，<strong>每种特征便是一个维度</strong>。假如你觉得描述一个人的特征太多，你想要用<strong>一两个或几个特征</strong>就个以描述一个人，并且<strong>这几个特征包含之前提到所有特征所包含的信息</strong>，将这么原来的众多特征转化为几个特征的过程就是<strong>降维</strong>。而降维后得到的特征包含的<strong>信息量的多少也叫做贡献率</strong>，信息量越多越能够反应本质。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里举一个最常用的水仙花的例子</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>包括sklearn他的好基友们啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>这是一个水仙花的案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">y = iris.target</span><br><span class="line">x = iris.data</span><br></pre></td></tr></table></figure><p>有<code>x.shape = (150, 4)</code>,即每朵花共有四个特征,分别为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iris.feature_names = </span><br><span class="line">                    [<span class="string">&#x27;sepal length (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;sepal width (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;petal length (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;petal width (cm)&#x27;</span>]</span><br></pre></td></tr></table></figure><p>而<code>y</code>是一个分类变量，分别为<code>[0,1,2]</code>代表三种不同的花</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>还是sklearn中的老三样:</p><ul><li>实例化PCA()</li><li>调用<code>fit()</code>函数</li><li>调用<code>transform()</code>函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pca = PCA(n_components = <span class="number">2</span>)</span><br><span class="line">pca = pca.fit(x)</span><br><span class="line">x_dr = pca.transform(x)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>n_components</code>表示降维后所得到的维度<br>或者也可以直接一步到位</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_dr = PCA(<span class="number">2</span>).fit_transform(x)</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看降维后所带有的信息量大小"><a href="#查看降维后所带有的信息量大小" class="headerlink" title="查看降维后所带有的信息量大小"></a>查看降维后所带有的信息量大小</h3><ul><li>两个维度信息量大小<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(pca.explained_variance_)</span><br></pre></td></tr></table></figure>可以得到<code>[4.22824171， 0.24267075]</code></li><li>两个维度贡献率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pca.explained_variance_ratio_</span><br></pre></td></tr></table></figure><p>可以得到<code>[0.92461872, 0.05306648]</code></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>当我们把数据降维后，可以观察其在新的维度上的分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">0</span>,<span class="number">0</span>],x_dr[y == <span class="number">0</span>,<span class="number">1</span>],c = <span class="string">&quot;red&quot;</span>,label = iris.target_names[<span class="number">0</span>])</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">1</span>,<span class="number">0</span>],x_dr[y == <span class="number">1</span>,<span class="number">1</span>],c = <span class="string">&quot;black&quot;</span>,label = iris.target_names[<span class="number">1</span>])</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">2</span>,<span class="number">0</span>],x_dr[y == <span class="number">2</span>,<span class="number">1</span>],c = <span class="string">&quot;orange&quot;</span>,label = iris.target_names[<span class="number">2</span>])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p>其中<code>x_dr[y = 0,0]用了布尔索引</code></p></blockquote><p>得到如下结果<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201123828720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>可以这是一个分簇的分布，也就是说降维之后其实已经比较好分类了</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="累计方差贡献率曲线"><a href="#累计方差贡献率曲线" class="headerlink" title="累计方差贡献率曲线"></a>累计方差贡献率曲线</h4><p>当选取维度不同时累计贡献率的曲线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_line = PCA().fit(x)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],np.cumsum(pca_line.explained_variance_ratio_))</span><br><span class="line">plt.xticks([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201123816813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="最大似然估计选择超参数"><a href="#最大似然估计选择超参数" class="headerlink" title="最大似然估计选择超参数"></a>最大似然估计选择超参数</h4><p>这种方法可以自动选出最合适的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_mle = PCA(n_components = <span class="string">&quot;mle&quot;</span>)</span><br><span class="line">pca_mle = pca_mle.fit(x)</span><br><span class="line">x_mle = pca_mle.transform(x)</span><br><span class="line">pca_mle.explained_variance_ratio_.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>比如上述例子为我们选了维度为3，累计贡献率高达0.994</p><h4 id="按贡献率选择"><a href="#按贡献率选择" class="headerlink" title="按贡献率选择"></a>按贡献率选择</h4><p>意味着你想要他的累计贡献率达到0.97时的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_f = PCA(n_components=<span class="number">0.97</span>,svd_solver=<span class="string">&quot;full&quot;</span>)</span><br><span class="line">pca_f = pca_f.fit(x)</span><br><span class="line">x_f = pca_f.transform(x)</span><br><span class="line"><span class="built_in">print</span>(pca_f.explained_variance_ratio_)</span><br></pre></td></tr></table></figure><p>贡献率分别为<code>[0.92461872, 0.05306648]</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn主成分分析PCA&quot;&gt;&lt;a href=&quot;#sklearn主成分分析PCA&quot; class=&quot;headerlink&quot; title=&quot;sklearn主成分分析PCA&quot;&gt;&lt;/a&gt;sklearn主成分分析PCA&lt;/h1&gt;&lt;h2 id=&quot;数学原理&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="pca" scheme="http://example.com/tags/pca/"/>
    
  </entry>
  
  <entry>
    <title>sklearn聚类算法Kmeans</title>
    <link href="http://example.com/2021/11/02/python-kmeans/"/>
    <id>http://example.com/2021/11/02/python-kmeans/</id>
    <published>2021-11-01T16:55:12.000Z</published>
    <updated>2021-11-01T17:05:38.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn聚类算法Kmeans"><a href="#sklearn聚类算法Kmeans" class="headerlink" title="sklearn聚类算法Kmeans"></a>sklearn聚类算法Kmeans</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>聚类算法是一种<strong>无监督学习算法</strong>，也就是说它不需要<strong>标签</strong>,只需要大量的特征就可以把数据集聚类，然后聚类在自己给他贴标签。 这里Kmeans的具体原理不作详述。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>通过sklearn自带的<code>make_blobs</code>函数可以生成聚类所需的数据集，注意，所生成的数据集是几个<strong>分簇</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">500</span>,n_features=<span class="number">2</span>,centers=<span class="number">4</span>,random_state=<span class="number">1</span>)</span><br><span class="line">fig, ax1 = plt.subplots(<span class="number">1</span>)</span><br><span class="line">ax1.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>],marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201163842174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>上面是聚类前的图像，其中<code>X</code>是一个二维数组，每行有一个点的横坐标和纵坐标，<code>y</code>是已经给好的分类，是一个一维的数组，代表不同数据所在的簇。，下图是实际按不同簇分开的数据<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201163856733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>聚类依然是通过</p><ul><li>类的实例化</li><li>fit()函数</li><li>可以直接同<code>.labels_</code>或<code>.fit_predict</code>得到分类结果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">cluster = KMeans(n_clusters = <span class="number">3</span>, random_state = <span class="number">0</span>)</span><br><span class="line">cluster = cluster.fit(X)</span><br><span class="line">y_pred = cluster.labels_</span><br><span class="line"><span class="comment">#y_pred = cluster.fit_predict(X)</span></span><br></pre></td></tr></table></figure>所得到的y_pred是一个一维矩阵，包含了每一个点对应的类分类，分别为0,1,2</li></ul><h4 id="类的质心"><a href="#类的质心" class="headerlink" title="类的质心"></a>类的质心</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centroid = cluster.cluster_centers_</span><br></pre></td></tr></table></figure><p><code>centroid == [[-7.09306648, -8.10994454], [-1.54234022,  4.43517599], [-8.0862351 , -3.5179868 ]]</code>代表所分三类的质心。可以说这个点的特征最能代表这一个分类</p><h4 id="聚类的评估"><a href="#聚类的评估" class="headerlink" title="聚类的评估"></a>聚类的评估</h4><p>Inertia指每个样本点到其中心点的距离之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inertia = cluster.inertia_</span><br></pre></td></tr></table></figure><p>但似乎对于某些细长的类来说表现显然不太好，所以用<strong>轮廓系数</strong>来评估。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score</span><br><span class="line">silhouette_score(X,y_pred)</span><br></pre></td></tr></table></figure><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">color = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;pink&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;gray&quot;</span>]</span><br><span class="line">fig, ax1 = plt.subplots(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    ax1.scatter(X[y_pred==i, <span class="number">0</span>], X[y_pred==i, <span class="number">1</span>]</span><br><span class="line">     ,marker=<span class="string">&#x27;o&#x27;</span></span><br><span class="line">     ,s=<span class="number">8</span></span><br><span class="line">     ,c=color[i]</span><br><span class="line">     )</span><br><span class="line">ax1.scatter(centroid[:,<span class="number">0</span>],centroid[:,<span class="number">1</span>]</span><br><span class="line">     ,marker=<span class="string">&quot;x&quot;</span></span><br><span class="line">     ,s=<span class="number">15</span></span><br><span class="line">     ,c=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>那几个黑叉叉就是质心<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201163926542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="分成4类会怎么样"><a href="#分成4类会怎么样" class="headerlink" title="分成4类会怎么样"></a>分成4类会怎么样</h4><p><strong>会更合理</strong><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201163940755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn聚类算法Kmeans&quot;&gt;&lt;a href=&quot;#sklearn聚类算法Kmeans&quot; class=&quot;headerlink&quot; title=&quot;sklearn聚类算法Kmeans&quot;&gt;&lt;/a&gt;sklearn聚类算法Kmeans&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="kmeans" scheme="http://example.com/tags/kmeans/"/>
    
  </entry>
  
  <entry>
    <title>python支持向量机SVM (sklearn)</title>
    <link href="http://example.com/2021/11/01/python-svm/"/>
    <id>http://example.com/2021/11/01/python-svm/</id>
    <published>2021-11-01T15:04:54.000Z</published>
    <updated>2021-11-01T17:32:48.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn支持向量机SVM"><a href="#sklearn支持向量机SVM" class="headerlink" title="sklearn支持向量机SVM"></a>sklearn支持向量机SVM</h1><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>说实话以前用支持向量机都是直接套进去的，不过现在看了看菜菜提供数学原理发现其实挺有意思(<del>是超有意思！！</del>)。此处就不详述了，这原理到处都是。反正这SVM和决策树一样,<strong>有支持向量分类(SVC)和支持向量回归(SVR)</strong>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面是一个SVC的案例</p><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X,y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>, random_state=<span class="number">0</span>,cluster_std=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">50</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165752700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>模型本身并不难，就是要画出相应的图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clf = SVC(kernel = <span class="string">&quot;linear&quot;</span>).fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(clf.predict(X))</span><br></pre></td></tr></table></figure><p>上述例子预测又对X自己预测了一变。按照核心代码依旧延续sklearn的风格，十分简单。</p><ul><li>实例化</li><li>fit()</li><li>predict(）。</li></ul><p>可视化可能优点麻烦,需要用到下面这个函数。这个函数只需输入<code>clf</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svc_decision_function</span>(<span class="params">model,ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line">    ylim = ax.get_ylim()</span><br><span class="line">    x = np.linspace(xlim[<span class="number">0</span>],xlim[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    y = np.linspace(ylim[<span class="number">0</span>],ylim[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    Y,X = np.meshgrid(y,x)</span><br><span class="line">    xy = np.vstack([X.ravel(), Y.ravel()]).T</span><br><span class="line">    <span class="comment">#decision_function这个函数可以返回给定的x,y点到决策边界（也就是点到SVM所得到划分线的距离）</span></span><br><span class="line">    P = model.decision_function(xy).reshape(X.shape)</span><br><span class="line">    ax.contour(X, Y, P,colors=<span class="string">&quot;k&quot;</span>,levels=[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],alpha=<span class="number">0.5</span>,linestyles=[<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>])</span><br><span class="line">    ax.set_xlim(xlim)</span><br><span class="line">    ax.set_ylim(ylim)</span><br></pre></td></tr></table></figure><blockquote><p>函数大概思路就是首先生成一个<strong>网格</strong>，然后<strong>计算网格中各个点到决策边界的距离</strong>，最后绘制<strong>等高线</strong>(算出的距离相等的一条线)。</p></blockquote><p>则可以写作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clf = SVC(kernel = <span class="string">&quot;linear&quot;</span>).fit(X,y)</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">50</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plot_svc_decision_function(clf)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165825224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>其中<strong>灰色实线</strong>就是<strong>决策边界</strong>，<strong>虚线之间的距离</strong>就是<strong>边际</strong>。而SVM就是要找到<strong>边际最大的一条决策边界</strong>，而上面那<strong>三个穿虚线而过的点</strong>就是<strong>支持向量</strong>（最下面那个红色不算），<strong>也就是离决策边界最近的3个点</strong>。</p><h3 id="线性不可分的情况"><a href="#线性不可分的情况" class="headerlink" title="线性不可分的情况"></a>线性不可分的情况</h3><p>这就是整个SVM我觉得最关键也最有意思的地方。从上面的图我们能够知道SVM实际上是找到一个<strong>超平面</strong>将各点分开。如果能找到自然就是<strong>线性可分</strong>的，<strong>那如果找不到呢？</strong></p><blockquote><p><strong>超平面</strong>就是比<strong>当前空间维度低一个维度的分界</strong>，对于<strong>二维平面来说是一条线</strong>，对于<strong>三维空间是一个面</strong>。</p></blockquote><p>对于这么一个案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_circles</span><br><span class="line">X,y = make_circles(<span class="number">100</span>, factor=<span class="number">0.1</span>, noise=<span class="number">.1</span>)</span><br><span class="line">X.shape</span><br><span class="line">y.shape</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">50</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165853324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>我们可以看出，<strong>不可能存在一条直线</strong>，能将红色和蓝色分开，所以它是<strong>线性不可分的</strong>，怎么办呢？答案是<strong>升维！！！</strong></p><p>对于原来每一个点，我们使用一个<strong>映射函数</strong>，使得从原来的<strong>二维点</strong>变为原来的<strong>三维点</strong>。对于原来一个点<strong>有(x0,y0)</strong>,<br><strong>从(x0,y0)变为(x1,y1,z1)</strong>,其中<strong>z1有</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1 = x0; y1 = y0; z1 = e^&#123;-(x^2+y^2)&#125; </span><br></pre></td></tr></table></figure><p>先别想这个函数是怎么来的，让我们先看看映射后的结果怎么样<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170007694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>这个结果非常的amazing啊，红色的点浮起来了，现在只需要用一个<strong>平面</strong>就能把红色和蓝色隔开,也就是说，<strong>升维之后线性可分了！</strong>(<del>当时就把我看湿了</del></p><p>下面是上面这个案例的完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_circles</span><br><span class="line">X,y = make_circles(<span class="number">100</span>, factor=<span class="number">0.1</span>, noise=<span class="number">.1</span>)</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">50</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svc_decision_function</span>(<span class="params">model,ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line">    ylim = ax.get_ylim()</span><br><span class="line">    x = np.linspace(xlim[<span class="number">0</span>],xlim[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    y = np.linspace(ylim[<span class="number">0</span>],ylim[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    Y,X = np.meshgrid(y,x)</span><br><span class="line">    xy = np.vstack([X.ravel(), Y.ravel()]).T</span><br><span class="line">    P = model.decision_function(xy).reshape(X.shape)</span><br><span class="line">    ax.contour(X, Y, P,colors=<span class="string">&quot;k&quot;</span>,levels=[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],alpha=<span class="number">0.5</span>,linestyles=[<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>])</span><br><span class="line">    ax.set_xlim(xlim)</span><br><span class="line">    ax.set_ylim(ylim)</span><br><span class="line">clf = SVC(kernel = <span class="string">&quot;linear&quot;</span>).fit(X,y)</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">50</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plot_svc_decision_function(clf)</span><br><span class="line">r = np.exp(-(X**<span class="number">2</span>).<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line">rlim = np.linspace(<span class="built_in">min</span>(r),<span class="built_in">max</span>(r),<span class="number">30</span>)</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_3D</span>(<span class="params">elev=<span class="number">30</span>,azim=<span class="number">30</span>,X=X,y=y</span>):</span></span><br><span class="line">    ax = plt.subplot(projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">    ax.scatter3D(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],r,c=y,s=<span class="number">50</span>,cmap=<span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line">    ax.view_init(elev=elev,azim=azim)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="comment">#下面这个如果你用的是jupyter就可以互动了</span></span><br><span class="line"><span class="comment">#from ipywidgets import interact,fixed</span></span><br><span class="line"><span class="comment">#interact(plot_3D,elev=[0,30],azip=(-180,180),X=fixed(X),y=fixed(y))</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br></pre></td></tr></table></figure><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>所以说上面这个映射函数到底是怎么来的呢，什么是核函数，又和<strong>核函数</strong>又什么关系呢？<br>首先SVM最终的决策函数是<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165911151.png#pic_center"                      alt="在这里插入图片描述"                ></p><ul><li>f(x_test)是最终的分类，定义为{-1,1}</li><li>其中sign是符号函数，大于0取1，小于0取-1。</li><li>y是标签，二分类有两个标签，取{-1,1}</li><li>x_i是支持向量</li><li>x_test是测试向量</li><li>b是一个常数</li></ul><p>很显然我们要计算<strong>x_i与x_test</strong>之间的<strong>内积</strong>,当我们<strong>升维</strong>之后，我们要算的的<strong>内积是映射(升维)后的内积</strong>。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165928310.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>那么我们定义核函数：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202165943334.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>现在我们就<strong>只需要直接把两个向量带入核函数，而不用先映射成高维再算内积</strong>。这其实省去了很多麻烦，因为计算映射其实挺复杂的。<br>注意，正是因为再<strong>SVM中我们只用到了高维函数的内积，所以只需要计算核函数即可</strong>，有了核函数，我们便能再<strong>低维计算高维的内积</strong>,(<del>这是一次低维生物对高维发起的伟大挑战</del>)显然我们有，只要<strong>映射函数不同，核函数就不同</strong>。<br>下面是sklearn中的几个核函数，个人建议用”rbf”，至于每一个核函数对应的映射函数，自己百度吧。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170029147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170111226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>并且有</p><ul><li><strong>线性核，尤其是多项式核函数在高次项时计算非常缓慢</strong></li><li><strong>rbf和多项式核函数都不擅长处理量纲不统一的数据集</strong><br>所以需要针对其进行标准化<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X = StandardScaler().fit_transform(X)</span><br></pre></td></tr></table></figure></li></ul><h3 id="重要参数C-软间隔和硬间隔"><a href="#重要参数C-软间隔和硬间隔" class="headerlink" title="重要参数C(软间隔和硬间隔)"></a>重要参数C(软间隔和硬间隔)</h3><p><strong>c:</strong></p><blockquote><p>浮点数，默认1，必须大于等于0，可不填<br>松弛系数的惩罚项系数。如果<strong>C值设定比较大</strong>，那<strong>SVC可能会选择边际较小</strong>的，能够更好地分类所有训练点的决策边界，不过模型的训练时间也会更长。如果<strong>C的设定值较小</strong>，那<strong>SVC会尽量最大化边界</strong>，决策功能会更简单，但代价是训练的准确度。换句话说，C在SVM中的影响就像正则化参数对逻辑回归的影响.</p></blockquote><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170125919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>1是少数类，0是多数类</p><ul><li><strong>准确率</strong>：Accuracy，所有预测正确的样本除以总样本,(11+00)/(11+10+01+00)</li><li><strong>精确率</strong>：Precision，预测的少数类中，真正的少数类的占比。11/(11+01)</li><li><strong>召回率</strong> ：Recall，又被称为敏感度(sensitivity)，真正率，查全率，表示所有真实为1的样本中，被我们预测正确的样本所占的比例,11/(11+10).</li><li><strong>假负率</strong>：False Negative Rate,1-Recall。没召回的占少数类的占比。10/（11+10）</li><li><strong>特异度</strong>：Specificity,表示所有真实为0的样本中，被正确预测为0的样本所占的比例，00/（01+00）</li><li><strong>假正率</strong>：False Positive Rate，1 - specificity就是一个模型将多数类判断错误的能力，01/(01+00)</li><li><strong>ROC曲线</strong>，横轴为假正率(FPR)，纵轴为召回率(Recall)，当曲线越往左上角偏说明效果越好，。</li><li><strong>AUC面积</strong>，它代表了ROC曲线下方的面积，这个面积越大，代表ROC曲线越接近左上角，模型就越好。<h3 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h3></li><li>首先生成数据集并带入模型训练<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line">class_1 = <span class="number">500</span> <span class="comment">#类别1有500个样本</span></span><br><span class="line">class_2 = <span class="number">50</span> <span class="comment">#类别2只有50个</span></span><br><span class="line">centers = [[<span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">2.0</span>, <span class="number">2.0</span>]] <span class="comment">#设定两个类别的中心</span></span><br><span class="line">clusters_std = [<span class="number">1.5</span>, <span class="number">0.5</span>] <span class="comment">#设定两个类别的方差，通常来说，样本量比较大的类别会更加松散</span></span><br><span class="line">X, y = make_blobs(n_samples=[class_1, class_2],centers=centers,cluster_std=clusters_std,random_state=<span class="number">0</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=<span class="string">&quot;rainbow&quot;</span>,s=<span class="number">10</span>)</span><br><span class="line">clf_proba = SVC(kernel=<span class="string">&quot;linear&quot;</span>,C=<span class="number">1.0</span>,probability=<span class="literal">True</span>).fit(X,y)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170141184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></li></ul><ul><li>其次把个点所预测得到的概率放入DataFrame里<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prob = clf_proba.predict_proba(X)</span><br><span class="line"><span class="comment">#将样本和概率放到一个DataFrame中</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">prob = pd.DataFrame(prob)</span><br><span class="line">prob.columns = [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br></pre></td></tr></table></figure></li><li>找出最佳阈值并画出ROC曲线并得到相应的FPR和Recall，以及AUC</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">FPR, recall, thresholds = roc_curve(y,prob.loc[:,<span class="string">&quot;1&quot;</span>], pos_label=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#此时的threshold就不是一个概率值，而是距离值中的阈值了，所以它可以大于1，也可以为负</span></span><br><span class="line"><span class="comment">#找到最佳阈值</span></span><br><span class="line">maxindex = (recall - FPR).tolist().index(<span class="built_in">max</span>(recall - FPR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thresholds:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(thresholds[maxindex])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;recall:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(recall[maxindex])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;FPR:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(FPR[maxindex])</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score <span class="keyword">as</span> AUC</span><br><span class="line">area = AUC(y,clf_proba.decision_function(X))</span><br><span class="line"></span><br><span class="line">plt.scatter(FPR[maxindex],recall[maxindex],c=<span class="string">&quot;black&quot;</span>,s=<span class="number">30</span>)</span><br><span class="line"><span class="comment">#把上述代码放入这段代码中：</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(FPR, recall, color=<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;ROC curve (area = %0.2f)&#x27;</span> % area)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.scatter(FPR[maxindex],recall[maxindex],c=<span class="string">&quot;black&quot;</span>,s=<span class="number">30</span>)</span><br><span class="line">plt.xlim([-<span class="number">0.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.ylim([-<span class="number">0.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Positive Rate&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Recall&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Receiver operating characteristic example&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170241370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><ul><li>最后进行预测，得出结果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(prob.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> prob.loc[i,<span class="string">&quot;1&quot;</span>] &gt; thresholds[maxindex]:</span><br><span class="line">        prob.loc[i,<span class="string">&quot;pred&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prob.loc[i,<span class="string">&quot;pred&quot;</span>] = <span class="number">0</span></span><br><span class="line">prob[<span class="string">&quot;y_true&quot;</span>] = y</span><br><span class="line">prob = prob.sort_values(by=<span class="string">&quot;1&quot;</span>,ascending=<span class="literal">False</span>)</span><br><span class="line">prob</span><br></pre></td></tr></table></figure></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/2021020217041740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><ul><li>得到混淆矩阵来评估<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix <span class="keyword">as</span> CM, precision_score <span class="keyword">as</span> P, recall_score <span class="keyword">as</span> R</span><br><span class="line">cm = CM(prob.loc[:,<span class="string">&quot;y_true&quot;</span>],prob.loc[:,<span class="string">&quot;pred&quot;</span>],labels=[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">cm</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210202170442247.png#pic_center"                      alt="在这里插入图片描述"                ></li></ul><p><strong>PS:这个案例用的是核函数是线性核，但又试了一遍还是‘rbf’比较好</strong>,<br><strong>并且其实不一定需要最佳阈值，要结合实际来看。</strong><br>例如，三星手机发生爆炸，三星想要召回率能达到100%，即宁可把没有问题的手机召回，也不能放过任何一个有问题的手机，阈值也要相应调整。</p><h3 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h3><p>多分类其实也很简单，应该是sklearn的多分类很简单，数学原理十分可怕。区别就是输入的Y多了几个分类而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clf = SVC(decision_function_shape=<span class="string">&#x27;ovo&#x27;</span>) clf.fit(X, Y)</span><br></pre></td></tr></table></figure><p>上面用的是ovo(one vs one)，也就是每一个类两两组合来构建,也可以选择’ovr’速度更快，效果不怎么样。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="参数class-weight"><a href="#参数class-weight" class="headerlink" title="参数class_weight"></a>参数class_weight</h4><p>如果你想追求最高的召回率，宁可错杀不可放过，那么<code>class_weight = &quot;balanced&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clf = SVC(kernel = kernel ,gamma=<span class="string">&quot;auto&quot;</span>,degree = <span class="number">1</span>,cache_size = <span class="number">5000</span>,class_weight = <span class="string">&quot;balanced&quot;</span>).fit(Xtrain, Ytrain)</span><br></pre></td></tr></table></figure><p>如果还想再高，那么<code>class_weight = &#123;1:10&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn支持向量机SVM&quot;&gt;&lt;a href=&quot;#sklearn支持向量机SVM&quot; class=&quot;headerlink&quot; title=&quot;sklearn支持向量机SVM&quot;&gt;&lt;/a&gt;sklearn支持向量机SVM&lt;/h1&gt;&lt;h2 id=&quot;原理概述&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="svm" scheme="http://example.com/tags/svm/"/>
    
  </entry>
  
</feed>
