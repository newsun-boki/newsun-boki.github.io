<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-23T18:58:02.587Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>强化学习笔记</title>
    <link href="http://example.com/2022/03/24/rl-note/"/>
    <id>http://example.com/2022/03/24/rl-note/</id>
    <published>2022-03-23T18:56:32.000Z</published>
    <updated>2022-03-23T18:58:02.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习阅读笔记"><a href="#强化学习阅读笔记" class="headerlink" title="强化学习阅读笔记"></a>强化学习阅读笔记</h1><p>以前总是对强化学习一窍不通，但看到各种演示视频总觉得非常有趣，于是花3块钱在淘宝上搞了本电子书开始了我的强化学习之旅。为了防止我学完之后什么也不记得，特此写下阅读笔记</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.974DU2BuhvAlmkyU3XYR7gAAAA?pid=ImgDet&rs=1"                                     ></p><h2 id="I-导论"><a href="#I-导论" class="headerlink" title="I. 导论"></a>I. 导论</h2><h3 id="1-1-强化学习"><a href="#1-1-强化学习" class="headerlink" title="1.1 强化学习"></a>1.1 强化学习</h3><p>强化学习的定义：<strong>学习做什么能使数值化的收益信号最大</strong>。学习者并不会被告知采取什么动作，而是通过自己的尝试去发现什么动作会产生最大的收益。</p><p>强化学习不是有监督学习，也不是无监督学习，而是独立的。其与无监督学习的区别是：</p><ul><li>无监督学习是寻找未标注数据的隐含结构的过程。</li><li>强化学习的目标是最大化收益信号。</li></ul><p>强化学习的两个关键特征：</p><ul><li>强化学习需要在试探与开发之间权衡。虽然强化学习智能体一定更喜欢过去有效产生收益的动作，但需要尝试从未选择过的动作，即<strong>走出“舒适圈”</strong>。</li><li>强化学习需要明确考虑目标导向的智能体与不确定环境的交互这一整体问题，而不是一些孤立的子问题。注意强化学习是<strong>完整的交互的</strong>。</li></ul><p>强化学习与心理学和神经科学之间关系紧密，是和人类或动物最接近的一种学习方式，受到生物学习系统的影响。</p><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><ul><li>alphaGo围棋大师</li><li>一只羚羊幼崽出生后尝试着站起来</li><li>准备早餐。你可知道准备一个早餐是多么复杂的一个流程。走进橱柜，打开橱柜等等等等，对于现在的机器人来说几乎是不可能的事情。</li></ul><h3 id="1-3-强化学习要素"><a href="#1-3-强化学习要素" class="headerlink" title="1.3 强化学习要素"></a>1.3 强化学习要素</h3><ul><li>策略：学习智能体在特定时间的行为方式。环境状态到动作的映射。</li><li>收益信号：强化学习中问题的目标，决定了什么是好什么是坏。类似痛苦或者愉悦，是一种短期的收益。</li><li>价值函数：从长远的角度看什么是好的。一个状态的价值是一个智能体从这个状态开始，对将来累计的总收益的期望</li></ul><p>收益信号和价值函数就像短期的愉悦与长远的快乐。价值是我们最为关心的，我们选择动作是基于最高价值。但确定价值比确定收益难的多。就像你现在知道学习是痛苦的(收益低),但你不知道这样学下去未来会怎么样(价值难以确定)。收益基本是由环境直接给予的，而价值必须综合评估，根据智能体在整个过程中的收益序列重新评估。<strong>价值评估方法才是整个强化学习的关键。</strong></p><ul><li>最后是对环境建立的模型。这个模型是用于预测的，是我们最终得出来的结果。</li></ul><h3 id="1-4-局限性和适用范围"><a href="#1-4-局限性和适用范围" class="headerlink" title="1.4 局限性和适用范围"></a>1.4 局限性和适用范围</h3><p>状态是强化学习的核心，这种状态是策略和价值函数的输入，又是模型的输入与输出。</p><p>解决强化学习问题的方法一定不只强化学习。比如可以通过遗传算法，模拟退火等<strong>进化算法</strong>来解决。这些方法不计算价值函数，而是选择收益最多的策略及其变种来产生下一代。对于策略空间较小的问题，这些算法是有效的。</p><p>强化学习是在于环境互动中不断学习的一类算法。</p><h3 id="1-5-强化学习的早期历史"><a href="#1-5-强化学习的早期历史" class="headerlink" title="1.5 强化学习的早期历史"></a>1.5 强化学习的早期历史</h3><p>强化学习的历史发展中有两条主线，在现代强化学习之前他们是相互独立的：</p><ul><li>源于动物学习心理学的试错法</li><li>最优控制问题以及使用价值函数和动态规划的解决方案</li></ul><p>还有时序差分的研究</p><h2 id="第一部分-表格型求解方法"><a href="#第一部分-表格型求解方法" class="headerlink" title="第一部分 表格型求解方法"></a>第一部分 表格型求解方法</h2><p>简单强化学习问题，状态和动作空间<strong>小</strong>到可以用数组或表格形式来表示价值函数。一般来说可以找到<strong>精确解</strong>。</p><h2 id="II-多臂赌博机"><a href="#II-多臂赌博机" class="headerlink" title="II. 多臂赌博机"></a>II. 多臂赌博机</h2><ul><li>评估性反馈：依赖于当前采取的动作，即采取不同的动作会得到不同的反馈（强化学习）</li><li>指导性反馈：不依赖于当前的动作，即采取不同的动作也会得到相同的反馈（其他机器学习）</li></ul><h3 id="2-1-一个k臂赌博机问题"><a href="#2-1-一个k臂赌博机问题" class="headerlink" title="2.1 一个k臂赌博机问题"></a>2.1 一个k臂赌博机问题</h3><p>重复的在k个选项或者动作中做出选择，每次做出选择都会获得一定数值的收益，收益是由选择的动作决定的平稳的概率分布。<strong>目标是</strong>：<strong>某一短时间内最大化总收益的期望</strong>。比如1000次选择内。</p><p>k个动作每一个在选择后都有一个<strong>期望</strong>或者平均收益称为这个动作的<strong>价值</strong>。在时刻$t$选择的动作为$A_t$，对应的收益为$R_t$。动作a对应的价值为$q_*(a)$,即动作a收益的期望：<br>$$<br>q_*(a) = E[R_t|A_t = a]<br>$$<br>一定要理解：<strong>价值是收益的期望</strong>。事实上我们并不能准确的知道价值，所以智能有一个对$t$时刻价值的估计叫做$Q_t(a)$，我们的目的就是让它逼近$q_*(a)$。</p><p>如果一直对某个价值进行估计，那么在任一时刻至少有一个动作的估计值会是最高的，将这些对应的最高估计价值对应的动作称为<strong>贪心</strong>的动作。如果你选择了这些贪心的动作，则称作<strong>开发</strong>，如果选择了其他看起来没那么好的动作，那就是<strong>试探</strong>。开发是贪心的选择短期收益最大的，而试探是在放弃短期收益，尝试有没有更好的选项。由于每一次选择，开发和试探不可能同时进行，这就是<strong>开发和试探的冲突</strong>。</p><p>开发和试探的平衡是强化学习中的一个重要问题。</p><h3 id="2-2-动作-价值方法"><a href="#2-2-动作-价值方法" class="headerlink" title="2.2 动作-价值方法"></a>2.2 动作-价值方法</h3><p>接下来讲的就是怎么<strong>估计动作对应的价值</strong>，计算$Q_t(a)$。最简单的自然是求动作对应的价值的期望。也就是我们可能先执行各种各样的动作，然后用执行动作a得到的收益总和除以执行动作a的次数就可以得到平均每次执行动作a的收益，即<strong>通过平均值来估计期望</strong>。</p><p>然后接下来用估计出的价值$Q_t(a)$来选择动作，使用之前我们所说的贪心，即选<strong>择估计值最大的那一个</strong>。可以记为<br>$$<br>A_t = \mathop{\arg\max}<em>{a}Q_t(a)<br>$$<br>这种方法根本不花时间去选择那些看起来劣质的动作，但是有的时候估计值也不一定对。因为估计的时间是有限的。此时可以用另一种近乎贪心的算法，比如有时候会以一个很小的概率$\epsilon$去等可能的选择其他不贪心的动作，称为$\epsilon$-贪心方法。这种方法的优点就是，假设时间无限长，那每一个动作都会被采样无限次，所得到的估计$Q_t(a)$就会收敛到$q</em>*(a)$。这不就可以很好的估计出哪个动作才是收益最高的了吗。</p><h3 id="2-3-10臂测试平台"><a href="#2-3-10臂测试平台" class="headerlink" title="2.3 10臂测试平台"></a>2.3 10臂测试平台</h3><p>我们来看一个实际案例，10臂，意为着有10种动作，每种动作对应着不同收益的概率分布如下图。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Screenshot-from-2022-03-24-01-51-48.75zfpp528940.webp"                      alt="Screenshot-from-2022-03-24-01-51-48" style="zoom:67%;"                 ><p>当然实际上我们应该是不知道上述分布的，而是我们试探来尽量估计。比如首先来个1000次来估计其每个动作的价值$Q_t(a)$，这构成了一轮试验。然后再搞2000次试验，得到我们对算法的评估。下图是贪心方法和$\epsilon$-贪心方法的对比。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Screenshot-from-2022-03-24-01-57-42.1w4upj91qvts.webp"                      alt="Screenshot-from-2022-03-24-01-57-42"                ></p><p>可以看出纯粹贪心的算法长远上来看效果是没有$\epsilon$-贪心方法好的，这是因为贪心方法陷入一个自己认为收益的动作后无法自拔，而$\epsilon$-贪心方法一直在尝试其他好的方法。事实上可以随着时间推移逐渐减小$\epsilon$效果会更好。</p><h3 id="2-4-增量式实现"><a href="#2-4-增量式实现" class="headerlink" title="2.4 增量式实现"></a>2.4 增量式实现</h3><p>事实上对于某一个动作，我们令$R_i$为这一动作被选择$i$次之后获得的收益，$Q_n$表示被选择$n-1$次之后价值的估计，有：<br>$$<br>Q_n= \frac{R_1+R_2+…+R_{n-1}}{n-1}<br>$$<br>但我们总不可能每进行一次动作都去算一下这个式子吧，那样只会随着次数的增多越来越麻烦，显然我们是能够仅仅根据$Q_n$和第$n$次收益$R_n$算出$Q_{n+1}$来的：<br>$$<br>Q_{n+1} = Q_n + \frac{1}{n}[R_n - Q_n]<br>$$<br>推导这里就不列出来了，因为非常简单，有没有发现这种形式很眼熟：<br>$$<br>新估计值 = 旧估计值 + 步长 \times [目标 - 旧估计值]<br>$$<br>这里的步长就是$\frac{1}{n}$,有点类似与梯度下降中学习率的样子，我们可以将它记为$\alpha$或者说$\alpha_t(a)$,即某一个动作某一时间的步长。用这种增量式的形式我们可以知道一个多臂赌博机$\epsilon$-贪心的解法。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Screenshot-from-2022-03-24-02-17-11.5p5i7i5ujhs0.webp"                      alt="Screenshot-from-2022-03-24-02-17-11" style="zoom:80%;"                 ><h3 id="2-5-跟踪一个非平稳的问题"><a href="#2-5-跟踪一个非平稳的问题" class="headerlink" title="2.5 跟踪一个非平稳的问题"></a>2.5 跟踪一个非平稳的问题</h3><p>前面我们跟踪的都是一个平稳的问题，即动作对应的真实价值是不随着时间变化的。但强化学习面对的问题往往都是非平稳的问题，即动作的真实价值是随着时间变化的，也就是说以前估计值过一段时间就不能用了，我们必须时刻保持估计值最新。按之前的写法：<br>$$<br>Q_{n+1} = Q_n + \frac{1}{n}[R_n - Q_n]<br>$$<br>我们显然可以发现越往后，后面的实际收益对估计值影响越小(因为$\frac{1}{n}$趋近于0)，所以我们大胆的将步长令为一个<strong>常数</strong>：<br>$$<br>Q_{n+1} = Q_n + \alpha[R_n - Q_n]<br>$$<br>这个里面$\alpha$就是一个属于(0,1]的常数。当然也会带来一些小小的问题，比如如果这是一个平稳问题，当步长取$\frac{1}{n}$时根据大数定理能够保证其收敛到一个真值，当然对于非平稳问题就不存在了。还有就是当步长变为常数时对于价值的估计就变成了一个有偏估计。</p><h3 id="2-6-乐观初始值"><a href="#2-6-乐观初始值" class="headerlink" title="2.6 乐观初始值"></a>2.6 乐观初始值</h3><p>乐观初始值体现在对初始值的改变。以前都是将初始估计值设置为0，现在我给它全部+5。与原来初始估计值设置为0相比，给它+5意味着鼓励动作-价值方法去试探，因为他会发现无论选哪一个都达不到5。当然随着时间不断增加，所谓智能体就会发现实际上哪一个动作的价值都不是5，但由于它前面已经试探了够多，保证他有充足的时间去估计动作对应的价值$Q(a)$,所以估计的也就比开始贪心就立马选择最好的动作准确。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Screenshot-from-2022-03-24-02-35-25.3fkmbfsidhe0.webp"                      alt="Screenshot-from-2022-03-24-02-35-25"                ></p><p>当然，这种方法<strong>对于非平稳情况几乎没用</strong>，因为改变初始值只能够影响一开始的状况，但显然之后价值不断变化初始值也不能产生任何影响。</p><h3 id="2-7-基于置信度上界的动作选择"><a href="#2-7-基于置信度上界的动作选择" class="headerlink" title="2.7 基于置信度上界的动作选择"></a>2.7 基于置信度上界的动作选择</h3><p>之前的$\epsilon$-贪心方法虽然有效，但毕竟也是在盲目的选择其他目标。事实上还有一种还有更好的方法，<strong>基于置信度上界(upper confidence bound, UCB)的方法</strong>。</p><p>这种方法的主要思想是，对于一种动作，我选择的次数越多，我就越不想选他，选一些没选过的。具体方程就是<br>$$<br>A_t = \mathop{\arg\max}_{a}[Q_t(a)+c\sqrt{\frac{lnt}{N_t(a)}}]<br>$$<br>其中$N_t{(a)}$表示$t$时刻前动作$a$被选择的次数，$c$是一个大于0的数，控制试探的程度。这种方法中平方根项决定了对$a$动作值估计的不确定性的度量，每次选$a$，不确定性会减小。假如长时间不选$a$,不确定性就会增加。</p><p>这种方法在10臂测试平台上效果确实是比$\epsilon$-贪心方法好，但难以推广到强化学习中的其他部分。</p><h3 id="2-10-本章小结"><a href="#2-10-本章小结" class="headerlink" title="2.10 本章小结"></a>2.10 本章小结</h3><p>为什么直接跳到2.10呢，因为前面的梯度赌博机和上下文关联算法懒得看了。这里总结一下，主要就是</p><ul><li>$\epsilon$-贪心方法。一小段时间内进行动作的随机选择。</li><li>UCB方法。采用确定的动作选择，但趋向于选择较少使用的动作.</li><li>梯度赌博机算法。不估计动作价值，而是利用偏好函数，使用softmax分布来以一种分级的概率的方法选择更好的动作。</li></ul><p>至于哪个方法最好，只能说在10臂测试平台上是UCB最好吧，但不同的问题也不一样。这些方法看起来简单，但事实上都是强化学习中最基本的思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;强化学习阅读笔记&quot;&gt;&lt;a href=&quot;#强化学习阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;强化学习阅读笔记&quot;&gt;&lt;/a&gt;强化学习阅读笔记&lt;/h1&gt;&lt;p&gt;以前总是对强化学习一窍不通，但看到各种演示视频总觉得非常有趣，于是花3块钱在淘宝上搞了本电子</summary>
      
    
    
    
    <category term="RL" scheme="http://example.com/categories/RL/"/>
    
    
    <category term="RL" scheme="http://example.com/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>tuo</title>
    <link href="http://example.com/2022/01/05/tuo/"/>
    <id>http://example.com/2022/01/05/tuo/</id>
    <published>2022-01-05T12:48:23.000Z</published>
    <updated>2022-01-05T14:16:09.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前哨站底部下装甲击打策略"><a href="#前哨站底部下装甲击打策略" class="headerlink" title="前哨站底部下装甲击打策略"></a>前哨站底部下装甲击打策略</h1><h2 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h2><p>前哨站底部小装甲改为旋转式小装甲，现在旋转方式不明。估计应该和小陀螺差不多，且应该不会太快。</p><p>所以我认为前哨站底部小装甲应该是一个缓慢旋转的小陀螺，但击打策略应该与小陀螺不同，有以下几点。</p><ul><li>前哨站装甲板旋转应该不会像小陀螺这么快，所以正常小陀螺时旋转速度大于识别速度的情况应该不存在，故可以进行一定的预测击打</li><li>击打小陀螺仅需判断出车的位置，瞄准车的中心点击打即可。但前哨站特别是英雄机器人在击打时应该目标是能够准确击打到小陀螺的位置。因此需要准确判断装甲板的位置。</li></ul><h2 id="慢速旋转状态"><a href="#慢速旋转状态" class="headerlink" title="慢速旋转状态"></a>慢速旋转状态</h2><p>翻了一下之前视频竟然还真有一个光原地旋转而不是小陀螺的视频(云台一起转)，转的比较慢，应该和前哨站下装甲板差不多，缺点就是旋转半径和前哨站区比较小。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/tuo.eazductfw5s.webp"                      alt="tuo"                ></p><h3 id="时域"><a href="#时域" class="headerlink" title="时域"></a>时域</h3><p>其旋转状态下主要为x坐标和z坐标发生变化，如下图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Figure_0.1xodx4eu51nk.webp"                      alt="Figure_0"                ></p><h3 id="频域"><a href="#频域" class="headerlink" title="频域"></a>频域</h3><p>可以看出x的变化还是非常的明显的，可以以此为依据判断陀螺状态，问题就是怎么让计算机理解它处于陀螺状态。本以为变换到频域之后会很明显，结果fft之后效果并不是特别好。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Figure_1-2.25p6jcejnpy8.webp"                      alt="Figure_1-2"                ></p><p>上图中左图为陀螺下的x和z的频域变换，而右图为随意运动下的频域变化，似乎不是太明显。</p><h3 id="一阶差分"><a href="#一阶差分" class="headerlink" title="一阶差分"></a>一阶差分</h3><p>对位置进行一阶差分后进行观察，可以看出会存在一些离群点是因为装甲板的迅速切换。但是考虑到实际中可能每次装甲板切换(不一定是小陀螺)都会产生这种东西，依然不是太好判别</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/Figure_2.1nwh5b2ulcio.webp"                      alt="Figure_2"                ></p><h2 id="旋转模式的判断"><a href="#旋转模式的判断" class="headerlink" title="旋转模式的判断"></a>旋转模式的判断</h2><p>要判断是否处于陀螺模式，经过上述研究，最终还是决定直接从时域上进行观察，还是时域上特征最为明显。</p><p>在时域上，最为明显的特点是不断增加然后突然返回原来的值然后又重新开始向上增加，针对这个特点需要设计一套算法。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>首先先无脑上神经网络看一下效果怎么样。针对这种时间序列数据，先试一下比较有名的长短神经网络lstm。原理在此不赘述，但现在由于数据集不足的原因，先不用这种无脑不优雅的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前哨站底部下装甲击打策略&quot;&gt;&lt;a href=&quot;#前哨站底部下装甲击打策略&quot; class=&quot;headerlink&quot; title=&quot;前哨站底部下装甲击打策略&quot;&gt;&lt;/a&gt;前哨站底部下装甲击打策略&lt;/h1&gt;&lt;h2 id=&quot;猜测&quot;&gt;&lt;a href=&quot;#猜测&quot; class=&quot;</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
  </entry>
  
  <entry>
    <title>Blender编程指南</title>
    <link href="http://example.com/2022/01/05/Blender-code/"/>
    <id>http://example.com/2022/01/05/Blender-code/</id>
    <published>2022-01-05T12:11:31.000Z</published>
    <updated>2022-01-05T12:15:48.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender编程指南"><a href="#Blender编程指南" class="headerlink" title="Blender编程指南"></a>Blender编程指南</h1><h2 id="什么是Blender"><a href="#什么是Blender" class="headerlink" title="什么是Blender"></a>什么是Blender</h2><p>blender是一个轻量级的三维建模软件，可以通过steam下载。随着Blender官方的不断更新，其功能不断完善，blender已经受到越来越多人欢迎。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-01-03-023105.6qw7kturlms0.webp"                      alt="屏幕截图-2022-01-03-023105"                ></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p>Blender图形化操作</p></li><li><p>Python基础语法</p></li></ul><p>本教程需要你掌握了Blender的大致操作和python的基础语法。然后看了这个教程能够大概将两项结合在一起。</p><h2 id="Blender编程"><a href="#Blender编程" class="headerlink" title="Blender编程"></a>Blender编程</h2><p>Blender作为一款三维建模软件，所使用的人大多数是学艺术的，但像我这种程序员，使用软件的第一想法就是是否能编程。Blender非常人性化的支持python编程功能，并且很多Blender第三方插件也是基于Blender编程模块所开发的。</p><p>所谓Blender的编程，事实上就是编写一个自动化脚本，来将我们几乎所有能够图形化的操作变成编程语言。这虽然听起来会很麻烦，但对于一些重复性的工作比如随机生成楼房草地等非常有帮助。</p><h2 id="编程前的环境设置"><a href="#编程前的环境设置" class="headerlink" title="编程前的环境设置"></a>编程前的环境设置</h2><p>Blender的编程模块就内嵌在软件当中，当然你也可以使用Vscode进行编程。不过这里使用Blender内置的文本编辑器。在编程开始之前，首先要确保开启Python工具提示。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/1.15js6kipotj4.webp"                      alt="1"                ></p><p>开启后，当你吧鼠标悬停到任意一个按钮上时，就会出现相应的变量。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/2.1ed8b41xmjcw.webp"                      alt="2"                ></p><h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p>首先在上面窗口栏的最右边你能够找到Scripting脚本窗口，点击进入脚本编写界面.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/3.57rrm00su200.webp"                      alt="3"                ></p><p>除了你平时见到的窗口，还额外多出三个窗口分别是：</p><ul><li>文本编辑器：位于最中央。是你编写脚本的地方</li><li>Python控制台：位于左中。一个可以交互式编写python脚本的终端。熟悉python的应该都知道，通过这个控制台可以很方便的学习脚本编写。同时这个控制台有按<code>TAB</code>键自动补全的功能。</li><li>信息：位于左下。每当你在图形化界面中做出一步操作时，相应的函数调用就会出现在这里。你可以这个信息为依据编写脚本，但是这里的信息很多时候都只是单独的一步操作，在编写脚本时不一定要按这个来。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/4.s298v8slj4w.webp"                      alt="4"                ></p><h2 id="编程过程"><a href="#编程过程" class="headerlink" title="编程过程"></a>编程过程</h2><p>假设你会使用Blender和Python，你想要知道的就是Blender中的每一种操作在blender中是如何对应的，你有3种方法：</p><p>1.首先图形化界面做一步，然后在信息里查看调用了哪个函数。但这样做的坏处就是很多时候我们写脚本的内容和信息里所查看到的习惯是不一样。以下面创建一个立方体并旋转x轴旋转30度为例。</p><p>这是是以脚本的样子写出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy <span class="comment">#导入blender的必备库</span></span><br><span class="line">bpy.ops.mesh.primitive_cube_add()<span class="comment">#创建立方体</span></span><br><span class="line">so = bpy.context.active_object<span class="comment">#将立方体对象赋予so</span></span><br><span class="line">so.rotation_euler[<span class="number">0</span>] += <span class="number">30</span> * <span class="number">3.1415</span> / <span class="number">180</span><span class="comment">#欧拉角旋转30度</span></span><br></pre></td></tr></table></figure><p>但是在图形化界面中里面，旋转一个立方体有两种方法：</p><ul><li><p>直接更改其旋转角度</p></li><li><p>按<code>r</code>手动拖动旋转</p><p>以下为图形化操作在信息界面显示</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#创建立方体</span></span><br><span class="line">bpy.ops.mesh.primitive_cube_add(enter_editmode=<span class="literal">False</span>, align=<span class="string">&#x27;WORLD&#x27;</span>, location=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), rotation=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), scale=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">#直接更改其旋转角度</span></span><br><span class="line">   bpy.context.<span class="built_in">object</span>.rotation_euler[<span class="number">0</span>] = <span class="number">0.523599</span> </span><br><span class="line">   <span class="comment">#按`r`手动拖动旋转</span></span><br><span class="line">   bpy.ops.transform.rotate(value=-<span class="number">0.523838</span>, orient_axis=<span class="string">&#x27;Z&#x27;</span>, orient_type=<span class="string">&#x27;VIEW&#x27;</span>, orient_matrix=((<span class="number">4.93038e-32</span>, <span class="number">1</span>, <span class="number">2.22045e-16</span>), (<span class="number">2.22045e-16</span>, <span class="number">4.93038e-32</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2.22045e-16</span>, <span class="number">4.93038e-32</span>)), orient_matrix_type=<span class="string">&#x27;VIEW&#x27;</span>, mirror=<span class="literal">False</span>, use_proportional_edit=<span class="literal">False</span>, proportional_edit_falloff=<span class="string">&#x27;SMOOTH&#x27;</span>, proportional_size=<span class="number">1</span>, use_proportional_connected=<span class="literal">False</span>, use_proportional_projected=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>​    从这里我们可以看出，同一个步骤有很多不同的方法，在编写脚本时我们尽量少用ops中的函数，推荐直接更改其属性。同时信息界面所得每个函数都包含很多默认的形参，在脚本编写时可以暂时不需要。</p><p>2.在控制台终端不断自动补全进行尝试。这也是一种较为有效的方法。鉴于编辑器没有自动补全功能。在控制台不断的自动补全并交互式的实验是非常有效。</p><p>3.之前说的python工具提示已经显示除了每个变量的名称，你可以以此作为对照修改值。</p><p>平时python用的大多数语法都是能用的，这就是一个加了个第三方库的python，正常使用就好。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>你已经学会了1+1=2了，现在是时候开始解微积分了。</p><p>了解怎么将图形化界面对应到python，接下来就是发挥你的智慧，大胆的进行尝试了。只要你足够了解python和blender，这些都不是难事。如果你是一个纯艺术生，建议不一定需要学习写脚本，或者就先学一下python吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Blender编程指南&quot;&gt;&lt;a href=&quot;#Blender编程指南&quot; class=&quot;headerlink&quot; title=&quot;Blender编程指南&quot;&gt;&lt;/a&gt;Blender编程指南&lt;/h1&gt;&lt;h2 id=&quot;什么是Blender&quot;&gt;&lt;a href=&quot;#什么是Blen</summary>
      
    
    
    
    <category term="Blender" scheme="http://example.com/categories/Blender/"/>
    
    
    <category term="-Blender" scheme="http://example.com/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>Blender使用实录</title>
    <link href="http://example.com/2022/01/05/Blender-use/"/>
    <id>http://example.com/2022/01/05/Blender-use/</id>
    <published>2022-01-05T12:10:02.000Z</published>
    <updated>2022-01-05T12:11:08.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender使用实录"><a href="#Blender使用实录" class="headerlink" title="Blender使用实录"></a>Blender使用实录</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Blender是一款轻量级的三维建模软件。比起我以前用过的C4D来说，Blender真的很小(只有不到200M)，所以强烈推荐作为入门三维建模软件。 </p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>直接steam搜索blender下载即可，不仅免费还自动更新。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/image.4csuxbke29k0.png"                                     ></p><h2 id="界面初始"><a href="#界面初始" class="headerlink" title="界面初始"></a>界面初始</h2><h3 id="查看三维模型常用快捷键"><a href="#查看三维模型常用快捷键" class="headerlink" title="查看三维模型常用快捷键"></a>查看三维模型常用快捷键</h3><ul><li>鼠标中键——–旋转</li><li>鼠标中键+shift——–平移</li><li>鼠标中键+alt——–每隔45度自动吸附的旋转</li><li>数字键12346789——–切换不同视图</li><li>数字键5——–切换透视或平视视图(当你需要查看三视图时这个很重要)</li><li>ctrl+p ——–用来添加父级</li><li>ctrl+j———搞成一个整体</li></ul><ul><li><p>旋转(R)平移(G)缩放(S)</p></li><li><p>旋转(R)平移(G)缩放(S)模式下按shift+x/y/z锁住某一轴</p></li><li><p>(alt+R/G/S)旋转/平移/缩放清零。</p></li><li><p>ctrl + space全屏状态</p></li><li><p>单独显示选中物体——– “/“</p></li><li><p>shift+d——-复制物体</p></li><li><p>alt+d——–同样是复制物体，且在编译模式下复制出的物体操作与原来同步 </p></li><li><p>ctrl+g——–选择点后按下将点加入顶点组</p></li></ul><h4 id="编辑模式下"><a href="#编辑模式下" class="headerlink" title="编辑模式下"></a>编辑模式下</h4><ul><li>选物体按tab进入物体的编辑模式</li><li>在编辑模式下选中面按e伸缩面</li><li>ctrl + 1/2/3切换选择点/线/面</li><li>i——–插入</li><li>ctrl+r——-环切</li><li>p——–奖物体分开</li></ul><h4 id="摄像机模式下"><a href="#摄像机模式下" class="headerlink" title="摄像机模式下"></a>摄像机模式下</h4><ul><li><p>按0进入摄像机模式</p></li><li><p>按home把取景框调到最大</p></li><li><p>可以开视角锁定</p></li></ul><h4 id="3D游标"><a href="#3D游标" class="headerlink" title="3D游标"></a>3D游标</h4><p>  3D游标是个非常方便的设计。</p><ul><li><p>shift+右键———放置3d游标，会将3D游标放到当前鼠标位置的物体表面</p></li><li><p>当你想在某个地方创建一个图形时会默认创建在3D游标处</p></li><li><p>视角锁定3D游标会很方便</p></li></ul><h2 id="地形设计"><a href="#地形设计" class="headerlink" title="地形设计"></a>地形设计</h2><ul><li>建立很宽的地面</li><li>将其细分为很多小块</li><li>用衰减编辑去调整</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="bool-tool"><a href="#bool-tool" class="headerlink" title="bool tool"></a>bool tool</h3><p>bool运算插件：先选中切割物体再选中被切割物体，按ctrl+小键盘上的减号-</p><h4 id="MACHINtool3"><a href="#MACHINtool3" class="headerlink" title="MACHINtool3"></a>MACHINtool3</h4><p>​    一个比较方便的快捷键插件，有以下快捷键</p><ul><li>TAB—–可选择编辑模式以及点线面</li><li>.——–可以选择以什么地方进行缩放旋转等操作</li><li>F——-从unity3D拿过来的快捷键，聚焦到物体，非常方便</li><li>ZQ——–原来是PGUP，PGDN，用来显示一些东西</li><li>shift+alt+xyz——–先选择一个物体a，再选择物体b，创建a关于b的对称。或者直接创建物体关于自身的对称</li><li>shift+s———将3d游标放到一个地方</li><li>4——–通过点生成面</li><li>alt+a——–对齐</li><li>shift+alt+左键——–选择闭环 </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概就是记住一些关键的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Blender使用实录&quot;&gt;&lt;a href=&quot;#Blender使用实录&quot; class=&quot;headerlink&quot; title=&quot;Blender使用实录&quot;&gt;&lt;/a&gt;Blender使用实录&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Blender" scheme="http://example.com/categories/Blender/"/>
    
    
    <category term="-Blender" scheme="http://example.com/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>yolov5中pt转openvino</title>
    <link href="http://example.com/2021/11/28/yolov5-openvino/"/>
    <id>http://example.com/2021/11/28/yolov5-openvino/</id>
    <published>2021-11-28T10:10:07.000Z</published>
    <updated>2021-11-28T13:05:38.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yolov5中pt转openvino"><a href="#yolov5中pt转openvino" class="headerlink" title="yolov5中pt转openvino"></a>yolov5中pt转openvino</h1><p>由于我发现我每次转一次我都要重新google一遍，感觉我贫瘠的大脑无法记下这几条简单的命令，所以记录一下。</p><h2 id="pt-转-onnx"><a href="#pt-转-onnx" class="headerlink" title="pt 转 onnx"></a>pt 转 onnx</h2><p>在yolov5的路径下使用<code>models/export.py</code>转换，默认会放到和<code>yolov5s.pt</code>同一路径下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python models/export.py --weights polygon_best.pt --img 640 --batch 1</span><br></pre></td></tr></table></figure><h2 id="onnx-转-openvino"><a href="#onnx-转-openvino" class="headerlink" title="onnx 转 openvino"></a>onnx 转 openvino</h2><p>先切换到指定目录下在运行python程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/intel/openvino_2021/deployment_tools/model_optimizer</span><br><span class="line"></span><br><span class="line">python mo.py --input_model ~/rm/polygon-weights/640-n/polygon_best.onnx --input_shape [1,3,640,640] --data_type FP32 --output_dir ~/rm/polygon-weights/640-n</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yolov5中pt转openvino&quot;&gt;&lt;a href=&quot;#yolov5中pt转openvino&quot; class=&quot;headerlink&quot; title=&quot;yolov5中pt转openvino&quot;&gt;&lt;/a&gt;yolov5中pt转openvino&lt;/h1&gt;&lt;p&gt;由于我发现我</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="yolov5" scheme="http://example.com/tags/yolov5/"/>
    
    <category term="openvino" scheme="http://example.com/tags/openvino/"/>
    
  </entry>
  
  <entry>
    <title>视觉进阶培训1-运动预测</title>
    <link href="http://example.com/2021/11/25/rm-train-1/"/>
    <id>http://example.com/2021/11/25/rm-train-1/</id>
    <published>2021-11-25T06:38:58.000Z</published>
    <updated>2021-11-25T06:46:47.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视觉进阶培训1-运动预测"><a href="#视觉进阶培训1-运动预测" class="headerlink" title="视觉进阶培训1-运动预测"></a>视觉进阶培训1-运动预测</h1><p>三维弹球，准确的来说有点像气体分子的运动，可以看成空间中有一个小球（无重力），以随机的速度在空间中游动，碰到边缘会反弹，而你要做的就是预测小球一定时间之后的位置。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><p>numpy 1.20</p></li><li><p>ros melodic</p></li><li><p>Eigen </p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/newsun-boki/3dBall.git</span><br><span class="line"><span class="built_in">cd</span> 3dBall</span><br><span class="line">catkin_make <span class="comment"># rm -rf ./build ./devel if exits</span></span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#记得每打开一个终端都要source一下</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line"></span><br><span class="line">rosrun random_ball simu.py <span class="comment">#用于生成小球</span></span><br><span class="line"></span><br><span class="line">rosrun random_ball basic_shapes <span class="comment">#用于生成绿色框</span></span><br><span class="line"></span><br><span class="line">rviz -d src/random_ball/rm.rviz <span class="comment">#在rviz中显示</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/ball.6tt9rynnjeo0.gif"                                     ></p><h2 id="任务说明"><a href="#任务说明" class="headerlink" title="任务说明"></a>任务说明</h2><h3 id="必要知识"><a href="#必要知识" class="headerlink" title="必要知识"></a>必要知识</h3><ul><li>c++/python基础知识</li><li>了解ros的topic机制</li><li>了解rviz的使用</li><li>卡尔曼滤波(KF)或扩展卡尔曼滤波(EKF)或抗差卡尔曼滤波(UKF)<h3 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h3></li></ul><p>已知小球小球当前时刻的三维坐标，预测小球一定时间之后所处的位置(反弹部分不作要求)。节点图如下。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-22-34.1hdjhcrer068.png"                      alt="节点图"                ></p><ul><li>节点<code>/basic_shapes</code>用于发布<code>/visualization_marker</code>话题，即绿色边界框。</li><li>节点<code>/random_ball</code>用于发布<code>/position</code>话题，即小球的位置。<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3></li></ul><h4 id="获取小球当前位置。"><a href="#获取小球当前位置。" class="headerlink" title="获取小球当前位置。"></a>获取小球当前位置。</h4><ul><li>当运行<code>rosrun random_ball simu.py</code>后，通过<code>rostopic list</code>可以查询到有小球当前位置话题<code>/position</code>。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-27-19.10uiu20b9brk.png"                                     ></li><li>发送内容为<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-29-11.1lyv1ga20kio.png"                                     ></li><li>发送的消息格式为<code>geometry_msgs/PointStamped</code>，关于数据格式的了解见roswiki。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-34-34.75bszbno3iw0.png"                                     ></li><li>发送频率大概是450hz<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-28-44.6s1gt3r2c3w0.png"                                     ></li></ul><p>这里需要重新写一个<strong>预测节点</strong>，并在节点内创建一个<code>Subscriber</code>用于订阅<code>/position</code>话题。</p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>使用各种卡尔曼滤波(如EKF)的手段进行<strong>预测</strong>。通过小球之前的位置预测小球一段时间之后的位置，具体预测多久可自行决定。这里需要你学习一些卡尔曼的相关知识，使用Eigen库辅助来完成一些数学运算，尽量不要使用opencv自带的卡尔曼滤波。推荐B站DR_CAN的卡尔曼滤波相关<a class="link"   href="https://www.bilibili.com/video/BV1ez4y1X7eR" >讲解视频<i class="fas fa-external-link-alt"></i></a>.但注意简单的卡尔曼是线性的，所以需要用一些如扩展卡尔曼等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-14-19-03.49vp6ibwwqm0.png"                                     ><br>虽然卡尔曼是一个滤波算法，但由于其方法特性同样可以用来做预测。还有一个卡尔曼用于<a class="link"   href="https://www.bilibili.com/video/BV1dQ4y1m7ZC" >预测小球的讲解视频<i class="fas fa-external-link-alt"></i></a>(这个视频给了我这次任务灵感，虽然我并没有看)</p><h4 id="RVIZ显示"><a href="#RVIZ显示" class="headerlink" title="RVIZ显示"></a>RVIZ显示</h4><p>这里你需要大概了解rviz的使用方法。rviz可以接受话题里的消息并将其显示出来，你需要做的就是将你预测的结果发布为<code>PointStamped</code>格式并使用rviz显示，如果不了解结果可以参考<code>simu.py</code>里的实现。将<strong>你的预测结果用换一个颜色的小球显示出来</strong>就好。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li><code>rosrun random_ball simu.py</code>这个命令<code>ctrl+c</code>似乎停不下来，你可以使用<code>ctrl+z</code>将其挂到后台暂停它,然后通过<code>jobs</code>查看后台任务,并使用<code>kill %num</code>杀死它，<code>num</code>为其在<code>jobs</code>查看时任务对应的序号。</li><li>由于物体是随机运动，所以预测一段之后的时间不能过长，当然也不能过短。至于是多少，你看着觉得多少合适就多少。</li><li>评价预测好坏主要有两个指标<ul><li> <strong>收敛速度</strong>。包括当小球从静止到运动需要多久才能开始准确预测，以及当小球撞击边缘速度发生突变时尽量收敛到正确方向的时间(可以采取一些如当检测速度突变就reset卡尔曼的手段)</li><li> <strong>预测结果的稳定性</strong>。在实际控制当中，为了使电机不震颤，视觉的预测结果需要尽量的平滑稳定，即预测点不要乱抖。</li></ul></li><li>如果你觉的这个弹球模型好玩，并且看懂了弹球代码，你可以编写<code>simu.py</code>程序自己往里面多加几个球并加上物理体积的碰撞。或者我一总觉得这个碰到边缘没有音效怪怪的，你可以自己往里面加点音效。</li><li>为了方便查看，这个README我也会发到博客上。<ul><li>gitee：<a class="link"   href="https://gitee.com/newsun-boki/Ball3d" >https://gitee.com/newsun-boki/Ball3d<i class="fas fa-external-link-alt"></i></a></li><li>github:<a class="link"   href="https://github.com/newsun-boki/3dBall" >https://github.com/newsun-boki/3dBall<i class="fas fa-external-link-alt"></i></a></li><li>博客： <a class="link"   href="https://newsun-boki.github.io/2021/11/25/rm-train-1/" >https://newsun-boki.github.io/2021/11/25/rm-train-1/<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视觉进阶培训1-运动预测&quot;&gt;&lt;a href=&quot;#视觉进阶培训1-运动预测&quot; class=&quot;headerlink&quot; title=&quot;视觉进阶培训1-运动预测&quot;&gt;&lt;/a&gt;视觉进阶培训1-运动预测&lt;/h1&gt;&lt;p&gt;三维弹球，准确的来说有点像气体分子的运动，可以看成空间中有一</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
    <category term="predict" scheme="http://example.com/tags/predict/"/>
    
    <category term="rviz" scheme="http://example.com/tags/rviz/"/>
    
  </entry>
  
  <entry>
    <title>KoroFileHeader-Vscode自动注释插件推荐</title>
    <link href="http://example.com/2021/11/22/KoroFileHeader/"/>
    <id>http://example.com/2021/11/22/KoroFileHeader/</id>
    <published>2021-11-22T14:55:16.000Z</published>
    <updated>2021-11-22T15:38:24.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KoroFileHeader-Vscode自动注释插件推荐"><a href="#KoroFileHeader-Vscode自动注释插件推荐" class="headerlink" title="KoroFileHeader-Vscode自动注释插件推荐"></a>KoroFileHeader-Vscode自动注释插件推荐</h1><p>写代码时注释是十分必要的，一个没有注释的代码几乎没人能看懂==屎山。</p><p>但是不得不说写注释是真的麻烦，而且我想写出一个好看一点的注释，让看得人也能赏心悦目，我就在想vscode有没有这么一款插件可以自动添加注释，结果您猜怎么着？还真有。</p><h2 id="KoroFileHeader-一款注释插件"><a href="#KoroFileHeader-一款注释插件" class="headerlink" title="KoroFileHeader-一款注释插件"></a>KoroFileHeader-一款注释插件</h2><ul><li>可用于代码段头的添加如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: liboyu </span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-Mo 10:48:22 </span></span><br><span class="line"><span class="comment"> * @Last Modified by:   liboyu </span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-11-Mo 10:48:22 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>也可以为函数添加注释,而且能够自动识别形参，你只需要把注释写在对应形参和返回值后就好啦</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @description: 初始化函数</span></span><br><span class="line"><span class="comment">    * @param &#123;string&#125; xml_path                     openvino模型的地址</span></span><br><span class="line"><span class="comment">    * @param &#123;double&#125; cof_threshold                置信度阈值</span></span><br><span class="line"><span class="comment">    * @param &#123;double&#125; nms_area_threshold           nms的iou重合面积阈值</span></span><br><span class="line"><span class="comment">    * @param &#123;int&#125; _class_number                   总共的类数</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(string xml_path,<span class="keyword">double</span> cof_threshold,<span class="keyword">double</span> nms_area_threshold,<span class="keyword">int</span> _class_number)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在vscode应用商店搜索KoroFileHeader安装。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>头部标注添加：快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i, linux: ctrl+meta+i,Ubuntu: ctrl+super+i</li><li>函数注释添加：快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t,linux: ctrl+meta+t, Ubuntu: ctrl+super+t</li></ul><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p><strong>这竟然还能一键添加各种奇奇怪怪的东西，这才是这个插件的精髓</strong>(如果你看网页源码的话会发现我也添加了一个小东西)<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://github.com/OBKoro1/koro1FileHeader/raw/master/images/codeDesign.gif?raw=true"                                     ></p><!-- * _______________#########_______________________  * ______________############_____________________  * ______________#############____________________  * _____________##__###########___________________  * ____________###__######_#####__________________  * ____________###_#######___####_________________  * ___________###__##########_####________________  * __________####__###########_####_______________  * ________#####___###########__#####_____________  * _______######___###_########___#####___________  * _______#####___###___########___######_________  * ______######___###__###########___######_______  * _____######___####_##############__######______  * ____#######__#####################_#######_____  * ____#######__##############################____  * ___#######__######_#################_#######___  * ___#######__######_######_#########___######___  * ___#######____##__######___######_____######___  * ___#######________######____#####_____#####____  * ____######________#####_____#####_____####_____  * _____#####________####______#####_____###______  * ______#####______;###________###______#________  * ________##_______####________####______________  -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KoroFileHeader-Vscode自动注释插件推荐&quot;&gt;&lt;a href=&quot;#KoroFileHeader-Vscode自动注释插件推荐&quot; class=&quot;headerlink&quot; title=&quot;KoroFileHeader-Vscode自动注释插件推荐&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
    <category term="vscode" scheme="http://example.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04录屏并生成gif图片</title>
    <link href="http://example.com/2021/11/18/ubuntu-record-sc/"/>
    <id>http://example.com/2021/11/18/ubuntu-record-sc/</id>
    <published>2021-11-17T17:47:51.000Z</published>
    <updated>2021-11-17T17:49:57.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu18-04录屏并生成gif图片"><a href="#Ubuntu18-04录屏并生成gif图片" class="headerlink" title="Ubuntu18.04录屏并生成gif图片"></a>Ubuntu18.04录屏并生成gif图片</h1><p>用kazam录屏ffmpeg转gif</p><p>标记一下这篇文章，以免我忘了每次都要去找：</p><p><a class="link"   href="https://blog.csdn.net/RedKeyer/article/details/89519984" >https://blog.csdn.net/RedKeyer/article/details/89519984<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu18-04录屏并生成gif图片&quot;&gt;&lt;a href=&quot;#Ubuntu18-04录屏并生成gif图片&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu18.04录屏并生成gif图片&quot;&gt;&lt;/a&gt;Ubuntu18.04录屏并生成gif图片&lt;/</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ROS新手介绍</title>
    <link href="http://example.com/2021/11/18/ros-begin/"/>
    <id>http://example.com/2021/11/18/ros-begin/</id>
    <published>2021-11-17T17:21:42.000Z</published>
    <updated>2021-11-17T19:05:45.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS介绍"><a href="#ROS介绍" class="headerlink" title="ROS介绍"></a>ROS介绍</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里只是ROS的基础入门的开始，做一个非常简单的讲解。</p><p>一般建议直接看官方文档：<a class="link"   href="http://wiki.ros.org/cn/ROS/Tutorials" >http://wiki.ros.org/cn/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>.</p><p>强烈建议看英文版：<a class="link"   href="http://wiki.ros.org/en/ROS/Tutorials" >http://wiki.ros.org/en/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>. 能够培养你阅读外的能力，毕竟大多数官方教程和写的好的教程是没有中文的。</p><h2 id="什么是ROS，为什么要用ROS"><a href="#什么是ROS，为什么要用ROS" class="headerlink" title="什么是ROS，为什么要用ROS"></a>什么是ROS，为什么要用ROS</h2><p>ROS的全称是<strong>Robot Operating System</strong>，也就是指<strong>机器人操作系统</strong>。但什么才是一个操作系统呢?想想现在都有些什么操作系统，Windows,linux,mac,Android等等，甚至你可能听过DOS系统，一个操作系统的基本特征有些什么呢？为什么ROS可以称为一个操作系统。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/ros.1xue58m21bj4.gif"                                     ></p><h3 id="分布式架构以及多进程"><a href="#分布式架构以及多进程" class="headerlink" title="分布式架构以及多进程"></a>分布式架构以及多进程</h3><p>想想你的Windows系统，你可以一边打游戏，一边看qq，后台还可能挂着杀毒软件，这些都是一个一个进程。一个操作系统运行往往包含大量的进程，但想想你写出来的代码，他可能是按着顺序来的，可能你把它放一个while循环里让他来回跑，或者你也可以多开几个线程让他分别跑着，但是这样还不够。</p><p>一个机器人，可能和人一样，有着眼睛(摄像头取流以及视觉目标检测),有着手(机械臂模块),脚(不同的底盘),还有着很多东西。这些东西光通讯就是一个大问题，更不要说让他们之间尽量互不干扰，但ros可以做到。就像你聊qq不耽误你打游戏一样。<strong>也就是说，在ros上，你实际上是可以运行多个程序，并且能够做到让这些程序间的数据互传。</strong></p><p>事实上，你也可以在其他的操作系统上做到这一点，例如通过SOCKER,管道，TCP协议等，但都没有ros方便快捷清晰。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-11-39.638zlyali1c0.png"                                     ></p><h3 id="功能的划分以及极强的可扩展性"><a href="#功能的划分以及极强的可扩展性" class="headerlink" title="功能的划分以及极强的可扩展性"></a>功能的划分以及极强的可扩展性</h3><p>在不用ros的时候，想想机器人是怎么控制的。冗长的代码，看不懂的结构，更是因为模块众多导致的代码量大，往往不知所措。然而有了ros，一切都不一样了。你可以把每个功能的模块分开，这里的分开不是简单的封装到一个个函数里。而是完全的分开，即多个不同的功能包，多个不同的代码，唯一的连接就是一些消息间的互传。这使得每一个模块结构清晰简单，代码可读性增强，且可扩展性极强。</p><h3 id="良好的生态"><a href="#良好的生态" class="headerlink" title="良好的生态"></a>良好的生态</h3><p>由于ROS得到越来越多机器人制作者的青睐，越来越多的机器人相关硬件软件抖做了ros适配的相关工作。就和Windows上的游戏支持比mac上多的多一样，很多时候你买到游戏没有Windows寸步难行。同样由于很多硬件如激光雷达等对ROS的支持,没有ros寸步难行。良好的生态也决定促使ros愈发蓬勃发展，现如今，ros里集成的大量的库，你可以用它来做slam定位建图导航，也可以用它来做自动驾驶汽车，还有利用第三方软件Gazebo模拟仿真等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-10-30.6000i1mywqg0.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ROS介绍&quot;&gt;&lt;a href=&quot;#ROS介绍&quot; class=&quot;headerlink&quot; title=&quot;ROS介绍&quot;&gt;&lt;/a&gt;ROS介绍&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>图片上传网络</title>
    <link href="http://example.com/2021/11/15/picx/"/>
    <id>http://example.com/2021/11/15/picx/</id>
    <published>2021-11-14T19:03:51.000Z</published>
    <updated>2021-11-14T19:36:46.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="picx图片上传网络"><a href="#picx图片上传网络" class="headerlink" title="picx图片上传网络"></a>picx图片上传网络</h1><p>在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，这个时候一般的选择是先将图片上传到github/gitee或csdn然后再使用网络链接，但还是不够方便，并且github需要翻墙才能看的问题，有个国人大佬就开发了一个名叫<strong>picx</strong>的东西。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/Screenshot-from-2021-11-15-03-07-58.5jhahkkrhcs0.png"                                     ><br>上面这界面就是使用picx上传的，本质上他还是借用了你自己的github仓库去放图片，然而它使用一个叫CDN加速的东西让你的图片可以很快的显示。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>github仓库:<a class="link"   href="https://github.com/XPoet/picx" >https://github.com/XPoet/picx<i class="fas fa-external-link-alt"></i></a></li><li>picx网页地址:<a class="link"   href="https://picx.xpoet.cn/#/upload" >https://picx.xpoet.cn/#/upload<i class="fas fa-external-link-alt"></i></a></li></ul><p>去github仓库看README教你如何在picx网页上配置，记得一定要使用生成的CDN加速的链接，否则就没有意义了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;picx图片上传网络&quot;&gt;&lt;a href=&quot;#picx图片上传网络&quot; class=&quot;headerlink&quot; title=&quot;picx图片上传网络&quot;&gt;&lt;/a&gt;picx图片上传网络&lt;/h1&gt;&lt;p&gt;在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="markdown" scheme="http://example.com/tags/markdown/"/>
    
    <category term="blog" scheme="http://example.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>livox-mid70激光雷达使用实录</title>
    <link href="http://example.com/2021/11/14/livox-detection/"/>
    <id>http://example.com/2021/11/14/livox-detection/</id>
    <published>2021-11-14T14:50:48.000Z</published>
    <updated>2021-11-14T19:36:52.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="livox-mid70激光雷达使用实录"><a href="#livox-mid70激光雷达使用实录" class="headerlink" title="livox-mid70激光雷达使用实录"></a>livox-mid70激光雷达使用实录</h1><p>livox-mid70是由大疆发布的面阵激光雷达，是大疆为自动驾驶推出的一款激光雷达，同时也可用于建立三维地图，文物修复，与大疆无人机相结合使用。你可以在x86和arm架构上都可以使用(arm需要交叉编译)。<br>bilibili上Livox官方发布了大量的视频demo可以去围观一下，同时Livox也有一个论坛可以去看一下。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a class="link"   href="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html" >https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html<i class="fas fa-external-link-alt"></i></a><br>这是中文官方文档，请根据以上文档完成硬件上的连接以及Ip配置，一切以官方文档为主。</p><ul><li>硬件连接</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/one_lidar_connect.png"                                     ></p><ul><li><p>更改IP：一般来说刚拿到手都是<strong>静态IP</strong>，这时候你只需要将网线与你自己笔记本相连，然后通过用户手册查看你自己雷达的IP，那需要设置你自己电脑的IP为手动，并将其分在同一网段不同的地址下：</p><pre><code>  如我的Mid70的IP地址为192.168.1.105，  那么我电脑设置时  IP：192.168.1.104，  子网掩码：255.255.255.0,  网关：192.168.0.1</code></pre></li></ul><p>如果对IP配置有问题,或想改为动态IP详情参见<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Mid%20Series%20User%20Manual%20(CN).pdf" >用户手册<i class="fas fa-external-link-alt"></i></a></p><h2 id="Livox-Viewer"><a href="#Livox-Viewer" class="headerlink" title="Livox Viewer"></a>Livox Viewer</h2><p>Livox Viewer是一款图形化操作的显示软件，有助于快速让你知道你的硬件连接和Ip配置有没有问题。</p><ul><li><a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Viewer%200.8.0.7z" >Livox-Viewer for Windows<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.livoxtech.com/3296f540ecf5458a8829e01cf429798e/downloads/Livox%20Viewer/Livox_Viewr_For_Linux_Ubuntu16.04_x64_0.7.0.tar.gz" >Livox-Viewer for ubuntu16.04<i class="fas fa-external-link-alt"></i></a>,下载后解压运行<code>./livox viewer.sh</code>即可打开如下界面。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/start_Viewer_and_link_Horizon.png"                                     ></li><li>官方软件Livox Viewer仅支持Windows或ubuntu16.04/14.04,所以建议如果不是这两个版本有ros可以直接上。</li></ul><h2 id="Livox-SDK"><a href="#Livox-SDK" class="headerlink" title="Livox-SDK"></a>Livox-SDK</h2><p>刚刚Livox Viewer只是一个快速尝试，如果你要做开发就<strong>必须</strong>要安装Livox-SDK(包括后面要在ros上使用也必须先要安装这个)</p><ul><li><p>github上中文<a class="link"   href="https://github.com/Livox-SDK/Livox-SDK/blob/master/README_CN.md" >README<i class="fas fa-external-link-alt"></i></a></p></li><li><p>先从github上clone下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/Livox-SDK.git</span><br></pre></td></tr></table></figure></li><li><p>再编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Livox-SDK</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>简单运行demo，注意这里的sample是在build文件夹下面的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sample/lidar &amp;&amp; ./lidar_sample</span><br></pre></td></tr></table></figure></li></ul><h2 id="livox-ros-driver"><a href="#livox-ros-driver" class="headerlink" title="livox-ros-driver"></a>livox-ros-driver</h2><p>不得不说ros是真的好用，所以建议在ros下使用，会使得一切都很清晰明了。装<code>livox-ros-driver</code>前必须要先装<code>Livox-SDK</code>。</p><ul><li><p>先从github上clone下来，这里一定要用下面这个命令把它clone到相应位置，否则会出问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src</span><br></pre></td></tr></table></figure></li><li><p>简单的<code>catkin_make</code>一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li><li><p>别忘了添加环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./devel/setup.sh</span><br></pre></td></tr></table></figure></li><li><p>之后跑个rviz的demo，让你的激光雷达点云数据在rviz里显示出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch</span><br></pre></td></tr></table></figure></li></ul><h2 id="录制你的点云数据"><a href="#录制你的点云数据" class="headerlink" title="录制你的点云数据"></a>录制你的点云数据</h2><p>点云数据不像二维图像一样，简简单单录制一个视频就好，作为点云数据记录是比较特殊的。<br>livox一共有两种录制格式</p><h4 id="lvx格式"><a href="#lvx格式" class="headerlink" title="lvx格式"></a>lvx格式</h4><p>lvx格式是livox的一种自定义格式，如果你想在Windows上快速录制，可以<strong>使用Livox Viewer进行录制</strong>，也可以<strong>通过<code>Livox-SDK</code>中的文件录制</strong></p><ul><li>首先进入以下路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./Livox_SDK/build/sample/lidar_lvx_file</span><br></pre></td></tr></table></figure></li><li>然后运行下面这个文件，这里不用<code>-c</code>指定也可以，这里指定了lidar并设定持续10s<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lidar_lvx_sample -c <span class="string">&quot;此处为已连接的Lidar的15位广播码&quot;</span> -t 10</span><br></pre></td></tr></table></figure>通过上面的操作会得到一个<code>.lvx</code>格式的文件，这个文件可以在Livox Viewer中直接播放，也可以转成<strong>rosbag</strong>(一个可以把ros中当前所有topic中message记录下来的东西)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver lvx_to_rosbag.launch lvx_file_path:=<span class="string">&quot;/home/livox/test.lvx&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="rosbag格式"><a href="#rosbag格式" class="headerlink" title="rosbag格式"></a>rosbag格式</h4><p>rosbag是ros中非常好用的一个东西，我在之前的ros文章中有提到过。当我们在运行livox-ros-driver中的rviz显示时，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch <span class="comment">#详情看上面livox-ros-driver</span></span><br></pre></td></tr></table></figure><p>我们可以把此时的所有消息用rosbag记录下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -a -o myrosbag.bag <span class="comment">#-a代表所有的消息,-c代表输出名称</span></span><br></pre></td></tr></table></figure><p>此时就会生成一个.bag文件，具体名称看终端的输出。<br>你可以通过以下命令进行播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -l <span class="comment">#-l代表loop循环播放</span></span><br></pre></td></tr></table></figure><p>此时再打开在livox-ros-driver下的的rviz,就可以得到rosbag中的点云图了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox/src/livox_ros_driver/</span><br><span class="line">rviz -d config/display_lidar_points.rviz <span class="comment">#这种.rviz文件实际上是保存rviz相关显示的数据</span></span><br></pre></td></tr></table></figure><h2 id="livox-detection"><a href="#livox-detection" class="headerlink" title="livox_detection"></a>livox_detection</h2><p>livox_detection指的是激光点云检测，livox官方给的代码可以检测各种车和行人。官方说2080ti下需要50ms。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/demo1.4a7m388oo240.gif"                                     ></p><p>在Livox官方的github仓库中有两个激光点云检测仓库分别为<code>livox_detection</code>和<code>livox_dection_simu</code>。<br>这两个仓库看上去都差不多，但实际上非常坑的是：</p><ul><li><code>livox_detection</code>仓库中的预训练模型在可以识别人和车，但车的识别效果不是很好;</li><li><code>livox_dection_simu</code>仓库中的预训练模型只能识别车，而几乎无法识别到人(虽然代码看上去都差不多)。</li></ul><p>至于原因我也不知道，只是这坑了我一会儿，后来在issue发现了这个问题。</p><p>由于两个仓库操作都非常相似，这里选livox_detection_simu为例。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>python3.6+</li><li>tensorflow1.13+ (tested on 1.13.0)</li><li>pybind11(后面的过程中安装)</li><li>ros</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>首先clone仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_detection_simu</span><br></pre></td></tr></table></figure></li><li><p>然后配置pybind(pybind就是这样，每次都需要clone在那个路径下才行)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> livox_detection_simu/utils/lib_cpp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pybind/pybind11.git</span><br></pre></td></tr></table></figure></li><li><p>编译(在刚刚的<code>lib_cpp</code>路径下)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>把c++得到的依赖文件放到项目根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp lib_cpp.so ../../../</span><br></pre></td></tr></table></figure></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/dataset/livox_detection_simu_model.zip" >预训练模型<i class="fas fa-external-link-alt"></i></a>,会得到model文件夹，把它放在项目根目录下，这样你就不用改模型地址了,</p></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/github/livox_detection_v1.1_data.zip" >rosbag<i class="fas fa-external-link-alt"></i></a>,这是官方提供的rosbag，你也可以自己录一个。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3></li><li><p>打开一个终端运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行rviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rviz -d ./config/show.rviz <span class="comment">#在livox_detection_simu仓库下</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -r 0.1 <span class="comment">#找到你存放rosbag的路径运行，发送消息间隔0.1s</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行目标检测程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python livox_detection_simu.py <span class="comment">#如果你的模型放在其他地方，你需要在config下将其模型路径改为你所放预训练模型的路径</span></span><br></pre></td></tr></table></figure></li></ul><p>由于目标检测速度相当慢，实时性非常差，队列里可能还缓存了很多帧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;a href=&quot;#livox-mid70激光雷达使用实录&quot; class=&quot;headerlink&quot; title=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;/a&gt;livox-mid70激光雷达使用实录&lt;/h1&gt;&lt;p&gt;li</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="lidar" scheme="http://example.com/tags/lidar/"/>
    
  </entry>
  
  <entry>
    <title>在线文本对比</title>
    <link href="http://example.com/2021/11/09/text-compare-md/"/>
    <id>http://example.com/2021/11/09/text-compare-md/</id>
    <published>2021-11-09T05:59:46.000Z</published>
    <updated>2021-11-09T06:03:25.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线文本对比"><a href="#在线文本对比" class="headerlink" title="在线文本对比"></a>在线文本对比</h1><p>推荐一个在线快速对比文本区别的网站：</p><p><a class="link"   href="https://text-compare.com/" >https://text-compare.com/<i class="fas fa-external-link-alt"></i></a></p><p>可能会需要翻墙，但还挺好用。</p><p>不用下载可以直接对比，发个博客留作记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在线文本对比&quot;&gt;&lt;a href=&quot;#在线文本对比&quot; class=&quot;headerlink&quot; title=&quot;在线文本对比&quot;&gt;&lt;/a&gt;在线文本对比&lt;/h1&gt;&lt;p&gt;推荐一个在线快速对比文本区别的网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="website" scheme="http://example.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>ros基本操作</title>
    <link href="http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-02T17:56:47.000Z</published>
    <updated>2021-11-09T05:58:41.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros基本操作"><a href="#ros基本操作" class="headerlink" title="ros基本操作"></a>ros基本操作</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>我们都知道话题机制是ros中必不可少的一个机制，那怎样查看我们所发布的话题呢</p><ul><li>list命令可以看到我们当前总共有哪些topic<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure></li><li>echo命令可以输出指定topic里的消息的内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo cmd_vel #cmd_vel是一个小海龟的速度topic</span><br></pre></td></tr></table></figure></li><li>hz命令可以计算指定topic消息发布的平均速率<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic hz cmd_vel</span><br></pre></td></tr></table></figure></li><li>info命令可以输出topic里的message的数据类型以及发布者接受者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic info cmd_vel</span><br></pre></td></tr></table></figure></li><li>rosmag show可以显示某个数据类型里具体的数据类型结构（注意这个和当前运行的程序没有关系）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg show geometry/Twist </span><br></pre></td></tr></table></figure>上面这个命令显示了geometry/Twist里包含的具体数据结构，如角速度(angular)xyz线速度(linear)xyz，geometry/Twist是cmd_vel这个topic里的消息的数据类型。</li></ul><h2 id="rqt"><a href="#rqt" class="headerlink" title="rqt"></a>rqt</h2><p>rqt是ros里可视化最基础的方式。</p><ul><li>rqt_graph可以显示出整个ros的分布式架构，包括节点，话题，服务等等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure></li><li>rqt_plot可以实时绘制出具体的话题里的消息里的一个或多个数据的变化曲线<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_plot cmd_vel/linear/x cmd_vel/angular/z</span><br></pre></td></tr></table></figure></li></ul><h2 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h2><p>rosbag可以记录消息，还可以重放消息。这对我们调试某个模块非常有帮助。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bagfiles</span><br><span class="line">rosbag record -a</span><br></pre></td></tr></table></figure><p>-a 选项表示将当前发布的所有 topic 数据都录制保存到一个 rosbag 文件中，录制的数据包名字为日期加时间。<br>也可以只记录某些感兴趣的 topic</p><ul><li>想要录制指定topic上的消息，你可以运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record cmd_vel</span><br></pre></td></tr></table></figure></li></ul><p>如果要指定生成数据包的名字，则用-O /-o 参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O filename.bag /topic_name1</span><br></pre></td></tr></table></figure><p>如果在 launch 文件中使用 rosbag record 命令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure><ul><li><p>rosbag info指令可以显示数据包中的信息:        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag info filename.bag</span><br></pre></td></tr></table></figure></li><li><p>rosbag play<br>接下来回放数据包中的 topic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果想改变消息的发布速率，可以用下面的命令，-r 后面的数字对应播放速率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果希望 rosbag 循环播放，可以用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br></pre></td></tr></table></figure><p>如果只播放感兴趣的 topic ，则用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br></pre></td></tr></table></figure><p>在上述播放命令执行期间，空格键可以暂停播放。</p></li></ul><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p>这里我就不写了<br>精品博客：<a class="link"   href="http://ttshun.com/2018/05/24/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8Broslaunch/" >http://ttshun.com/2018/05/24/ROS学习之roslaunch/<i class="fas fa-external-link-alt"></i></a><br>来自励志献身slam的阿翔，里面有很多好的博文都可以去看一看，特别是slam相关的</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>未完待续，这里有一篇 比较详细的代码建议详细看一看：<a class="link"   href="http://ttshun.com/2018/03/22/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%91%BD%E4%BB%A4/" >http://ttshun.com/2018/03/22/ROS学习之基本概念和命令/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros基本操作&quot;&gt;&lt;a href=&quot;#ros基本操作&quot; class=&quot;headerlink&quot; title=&quot;ros基本操作&quot;&gt;&lt;/a&gt;ros基本操作&lt;/h1&gt;&lt;h2 id=&quot;topic&quot;&gt;&lt;a href=&quot;#topic&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>rosserial进行串口通信</title>
    <link href="http://example.com/2021/11/02/rosserial/"/>
    <id>http://example.com/2021/11/02/rosserial/</id>
    <published>2021-11-01T17:56:47.000Z</published>
    <updated>2021-11-02T16:34:56.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rosserial进行串口通信"><a href="#rosserial进行串口通信" class="headerlink" title="rosserial进行串口通信"></a>rosserial进行串口通信</h1><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><ul><li>用于两个模块之间传输数据，是我们最常用的数据通信方式之一。包括单片机之间的通信，单片机与工控机之间的通信，单片机与外设模块之间的通信等等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-11-20.iyynbl97fo8.png"                      style="zoom:80%;"                 ><ul><li>由于 CPU 与接口之间按并行方式传输，接口与外设之间按串行方式传输，因此，在串行接口中，必须要有 “ 接收移位寄存器 “ （串→并）和 “ 发送移位寄存器 “ （并→串）.</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-16-55.67nf1dm75zk0.png"                      style="zoom: 67%;"                 ><ul><li>串口通讯是以高低电平为传输媒介，一位一位的传输，这一点是后面需要时刻牢记的。</li></ul><h3 id="具体发送的过程"><a href="#具体发送的过程" class="headerlink" title="具体发送的过程"></a>具体发送的过程</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-21-41.3wv7h75f5fg0.png"                                     ></p><ul><li><p>波特率：传输速度的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数。如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。</p></li><li><p>数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包的数据位数，标准值是6、7和8位。比如，当我想发送一个uint8的整数，它就刚好能够完整发送。</p></li><li><p>我们只需要记住的是，串口一次只能发送8位二进制数，所以要发送和接受的数据是以8位二进制数的数组存储的，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> buffer[<span class="number">12</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h3><p>那既然我们一次只能发8位数字，那对于float这种32位的数字要怎么发呢？</p><p>答案是把它拆开为4个8位数字发出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">3.5</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f1 = (*((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;(x)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;                <span class="comment">//4个字节的float x转换为buffer中的4位</span></span><br><span class="line">        <span class="keyword">uint8_t</span> tmp = (f1 &gt;&gt; (<span class="number">8</span> * i)) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buffer[i] = tmp;                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看上去拆开的方法显然没有我们想的那么简单。</li><li>我们知道<code>float</code>的数据存储类型是比较复杂的，有尾数幂数等等巴拉巴拉。当我们把其拆分的时候会遇到许多问题，为了更好的运算，我们将其转换为无符号32位整数,即<code>unsigned int</code>。</li><li>仔细看上面的代码<code> unsigned int f1 = (*((unsigned int *)&amp;(x)))</code>，你可能会感觉很疑惑这行代码，但你细看或许就明白了。</li><li>实际上是把x的指针类型强行从<code>float</code>变成<code>unsigned int</code>。这样的好处是其在内存中的值不会变,那个二进制数还是那些，而我们直接使用类型转换实际上会改变其在内存中的值。</li></ul><p>同样再收到消息的时候我们也需要相同的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span> ; i--)&#123;            <span class="comment">//vertical pitch</span></span><br><span class="line">    hor += buffer[i];</span><br><span class="line">    <span class="keyword">if</span>(i) hor &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">yaw = (*((<span class="keyword">float</span>*)&amp;hor));</span><br></pre></td></tr></table></figure><h3 id="Ubuntu中串口通讯"><a href="#Ubuntu中串口通讯" class="headerlink" title="Ubuntu中串口通讯"></a>Ubuntu中串口通讯</h3><p>Ubuntu下的串口助手cutecom可以快速帮你查看是否有串口信号传入你的ubuntu。(虽然我之前并没有用过，使用方法也可以请教电控组成员或自行谷歌，如果不大行就算了吧)</p><ul><li><p>安装cutecom并打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cutecom</span><br><span class="line">sudo cutecom</span><br></pre></td></tr></table></figure></li><li><p>查看连接你电脑的串口信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev | grep ttyU* <span class="comment">#/dev路径下通常包含了所连外设，故要查看串口需要在这里进行查看，而grep是正则化，只查看名字是ttyU开头的文件</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyS* <span class="comment">#网上看到的，不知道行不行</span></span><br></pre></td></tr></table></figure><p>你可以通过拔插串口看哪一个设备改变从而确定设备名称。</p><p>详细的你可以看我随便找的一个链接：<a class="link"   href="https://blog.csdn.net/maizousidemao/article/details/103236666" >https://blog.csdn.net/maizousidemao/article/details/103236666<i class="fas fa-external-link-alt"></i></a></p></li></ul><h4 id="Ros中的串口通讯"><a href="#Ros中的串口通讯" class="headerlink" title="Ros中的串口通讯"></a>Ros中的串口通讯</h4><p>Ros使用rosserial包作为串口通信的方式</p><ol><li>首先下载rosserial</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-serial</span><br></pre></td></tr></table></figure><ul><li>进入安装位置确认是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd serial</span><br></pre></td></tr></table></figure><ul><li>若是成功则能够进入位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/melodic/share/serial</span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后创造工作空间,参照<a class="link"   href="https://blog.csdn.net/liuxiaodong400/article/details/88072502" >这个博客<i class="fas fa-external-link-alt"></i></a></p></li><li><p>创造功能包并编写以下代码</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serial_port.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;serial/serial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;serial_port&quot;</span>);</span><br><span class="line">    <span class="comment">//创建句柄（虽然后面没用到这个句柄，但如果不创建，运行时进程会出错）</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个serial类</span></span><br><span class="line">    serial::Serial sp;</span><br><span class="line">    <span class="comment">//创建timeout</span></span><br><span class="line">    serial::Timeout to = serial::Timeout::<span class="built_in">simpleTimeout</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//设置要打开的串口名称</span></span><br><span class="line">    sp.<span class="built_in">setPort</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>);</span><br><span class="line">    <span class="comment">//设置串口通信的波特率</span></span><br><span class="line">    sp.<span class="built_in">setBaudrate</span>(<span class="number">115200</span>);</span><br><span class="line">    <span class="comment">//串口设置timeout</span></span><br><span class="line">    sp.<span class="built_in">setTimeout</span>(to);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开串口</span></span><br><span class="line">        sp.<span class="built_in">open</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(serial::IOException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR_STREAM</span>(<span class="string">&quot;Unable to open port.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断串口是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(sp.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO_STREAM</span>(<span class="string">&quot;/dev/ttyUSB0 is opened.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取缓冲区内的字节数</span></span><br><span class="line">        <span class="keyword">size_t</span> n = sp.<span class="built_in">available</span>();</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//读出数据</span></span><br><span class="line">            n = sp.<span class="built_in">read</span>(buffer, n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//16进制的方式打印到屏幕</span></span><br><span class="line">                std::cout &lt;&lt; std::hex &lt;&lt; (buffer[i] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//把数据发送回去</span></span><br><span class="line">            sp.<span class="built_in">write</span>(buffer, n);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭串口</span></span><br><span class="line">    sp.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CmakeLists如下:</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(serial_com)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Compile as C++11, supported in ROS Kinetic and newer</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span> <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  OpenCV REQUIRED</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  serial</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Declare a C++ library</span></span><br><span class="line"><span class="comment"># add_library($&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   src/$&#123;PROJECT_NAME&#125;/serial_com.cpp</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(stm_com</span><br><span class="line">  serial_port.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(stm_com <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(stm_com</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>运行roscore，运行节点看是否能打开串口。如果提示Unable to open port，是由于权限不够引起的，进行如下操作<br>创建文件:（若使用的是ttyACM将ttyusb替换即可）</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>udev<span class="regexp">/rules.d/</span><span class="number">70</span>-ttyusb.rules</span><br></pre></td></tr></table></figure><p>在打开的文件中添加</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KERNEL</span>==<span class="string">&quot;ttyUSB[0-9]*&quot;</span>, <span class="type">MODE</span>=<span class="string">&quot;0666&quot;</span></span><br></pre></td></tr></table></figure><p>或者直接更改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/ttyUSB*<span class="comment">#后面这个是你的串口设备</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rosserial进行串口通信&quot;&gt;&lt;a href=&quot;#rosserial进行串口通信&quot; class=&quot;headerlink&quot; title=&quot;rosserial进行串口通信&quot;&gt;&lt;/a&gt;rosserial进行串口通信&lt;/h1&gt;&lt;h2 id=&quot;串口通信&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>从神经网络到深度学习</title>
    <link href="http://example.com/2021/11/02/mlbasic/"/>
    <id>http://example.com/2021/11/02/mlbasic/</id>
    <published>2021-11-01T17:50:00.000Z</published>
    <updated>2021-11-04T10:54:20.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从神经网络到深度学习"><a href="#从神经网络到深度学习" class="headerlink" title="从神经网络到深度学习"></a>从神经网络到深度学习</h1><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在之前我们已经介绍过了一些优化问题，然而并不是所有优化问题从输入到目标函数之间都有明确的公式。不如说，在生活中大部分时候我们都很难建立一个很准确的数学模型，同时也无法得知需要优化什么参数，特别是对于图片分类来说。例如，给你一张图片，让你分辨是猫还是狗。对于输入来说，我们有一张图片rgb三通道的所有值，而需要输出0或1分别代表猫和狗。为了解决这个问题，我们引入神经网络等相关一系列概念。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2020.cnblogs.com/blog/1839046/202012/1839046-20201213200410529-875096804.png"                      alt="猫狗"                ></p><h2 id="机器学习-神经网络-深度学习"><a href="#机器学习-神经网络-深度学习" class="headerlink" title="机器学习 神经网络 深度学习"></a>机器学习 神经网络 深度学习</h2><p>首先，有必要对神经网络、深度学习、机器学习的概念做个简单描述。</p><p>神经网络，该模型灵感来自动物的中枢神经系统，通常呈现为相互连接的“神经元”，它可以对输入值通过反馈机制使得它们适应对应的输出。</p><p>深度学习是神经网络的进阶版，它的基本思路与神经网络类似，但往往比神经网络有着更复杂的结构以及优化算法，是神经网络的纵向延伸，常见的模型有CNN, RNN, LSTM等。</p><p>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>下面的图片很好地描述了这三者之间的关系</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://pic1.zhimg.com/80/v2-6d2584526f458fa512543d04ffb66c42_1440w.jpg?source=1940ef5c"                      alt="区别"                > </p><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><p><a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/1_ML_Basics.pdf" >ML<i class="fas fa-external-link-alt"></i></a></p><h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><p><strong>好的入门博文</strong>：<a class="link"   href="https://www.cnblogs.com/subconscious/p/5058741.html" >神经网络入门<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络实践与理解</strong>：<a class="link"   href="http://playground.tensorflow.org/" >tensorflow游乐场<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络的详细理解</strong>：<a class="link"   href="https://b23.tv/c44LK8" >吴恩达神经网络<i class="fas fa-external-link-alt"></i></a></p><p><strong>自己的板书</strong>:<a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/ml_nn.pdf" >ml_nn<i class="fas fa-external-link-alt"></i></a></p><h2 id="pytorch的相关介绍"><a href="#pytorch的相关介绍" class="headerlink" title="pytorch的相关介绍"></a>pytorch的相关介绍</h2><p>pytorch是python的第三方库，是由facebook开源的神经网络框架，并有专门针对GPU加速模型训练的模块。与tensorflow不同，pytorch编程简洁，接口简单，且速度不逊色于其他框架，是当前神经网络最简洁，高效的实现方法之一。</p><p><strong>好的博文</strong>：<a class="link"   href="https://zhuanlan.zhihu.com/p/265394674?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=907670979105415168" >知乎pytorch<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从神经网络到深度学习&quot;&gt;&lt;a href=&quot;#从神经网络到深度学习&quot; class=&quot;headerlink&quot; title=&quot;从神经网络到深度学习&quot;&gt;&lt;/a&gt;从神经网络到深度学习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="machine leaning" scheme="http://example.com/tags/machine-leaning/"/>
    
  </entry>
  
  <entry>
    <title>sklearn决策树</title>
    <link href="http://example.com/2021/11/02/python-dt/"/>
    <id>http://example.com/2021/11/02/python-dt/</id>
    <published>2021-11-01T17:31:38.000Z</published>
    <updated>2021-11-01T17:34:28.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn决策树"><a href="#sklearn决策树" class="headerlink" title="sklearn决策树"></a>sklearn决策树</h1><h3 id="参数表示"><a href="#参数表示" class="headerlink" title="参数表示"></a>参数表示</h3><p>决策树中有<strong>参数</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DecisionTreeClassifier(criterion=<span class="string">&quot;gini&quot;</span></span><br><span class="line">           , splitter=<span class="string">&quot;best&quot;</span></span><br><span class="line">                    , max_depth=<span class="literal">None</span></span><br><span class="line">                    , min_samples_split=<span class="number">2</span></span><br><span class="line">                    , min_samples_leaf=<span class="number">1</span></span><br><span class="line">                    , min_weight_fraction_leaf=<span class="number">0.</span></span><br><span class="line">                    , max_features=<span class="literal">None</span></span><br><span class="line">                    , random_state=<span class="literal">None</span></span><br><span class="line">                    , max_leaf_nodes=<span class="literal">None</span></span><br><span class="line">                    , min_impurity_decrease=<span class="number">0.</span></span><br><span class="line">                    , min_impurity_split=<span class="literal">None</span></span><br><span class="line">                    , class_weight=<span class="literal">None</span>,</span><br><span class="line">                    presort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>以下几个参数较为重要</p><blockquote><ul><li><strong>criterion</strong> : string, optional (default=”gini”)<br><u>用以设置用信息熵还是基尼系数计算。</u><br>(1).criterion=’gini’,分裂节点时评价准则是Gini指数。<br>(2).criterion=’entropy’,分裂节点时的评价指标是信息增益(模型欠拟合时使用)。</li><li><strong>max_depth</strong> : int or None, optional (default=None)。<br><u>指定树的最大深度</u>。 如果为None，表示树的深度不限。直到所有的叶子节点都是纯净的，即叶子节点 中所有的样本点都属于同一个类别。或者每个叶子节点包含的样本数小于min_samples_split。</li><li><strong>splitter</strong> : string, optional (default=”best”)。<br><u> 指定分裂节点时的策略。 </u><br>(1).splitter=’best’,表示选择最优的分裂策略。<br>(2).splitter=’random’,表示选择最好的随机切分策略。</li><li><strong>min_samples_leaf</strong> : int, float, optional (default=1)<br><u> 限定每个节点分枝后子节点至少有多少个数据，否则就不分枝</u>。<br>(1).如果为整数，则min_samples_split就是最少样本数。<br>(2).如果为浮点数(0到1之间)，则每个叶子节点最少样本数为ceil(min_samples_leaf * n_samples)</li></ul></blockquote><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在编写代码时，对数据的预处理主要包括对数据的<strong>导入</strong>，<strong>补全</strong>与<strong>删减</strong>，<strong>x与y的选取</strong>，将<strong>字典变量转化为虚拟变量</strong>等</p><ol><li><strong>导入数据</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier </span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridsearchCV</span><br><span class="line">data = pd.read_csv(<span class="string">&quot;your_ducument&quot;</span>)</span><br><span class="line"><span class="comment">#查看数据信息</span></span><br><span class="line">data.info()</span><br><span class="line"><span class="comment">#显示表的前10行</span></span><br><span class="line">data.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><strong>删除特征</strong><br>对于一些不需要的特征，例如<u>明显与因变量关系不大的特征</u>或是<u>缺失值实在太多难以填补的特征</u>可以适当性的直接拿掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">&quot;被拿掉的特征名1，被拿掉特征名2&quot;</span>], inplace = <span class="literal">True</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>inplace = True</code>指的是将替换原有的data,即等价于<code>data = data.drop([&quot;被拿掉的特诊名1，被拿掉特诊名2&quot;],axis = 1)</code>。<br>关于<code>axis = 1</code>,只的是对<strong>列</strong>操作，即对<strong>每一行</strong>操作.</p></blockquote><ol start="3"><li><strong>填充缺失值</strong><br>假设我们有一特征为年龄(age)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用平均值来填补缺失值</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].fillna(data[<span class="string">&quot;age&quot;</span>].mean())</span><br></pre></td></tr></table></figure>当某特征仅缺失较少的值时，把缺失的那个数据所在行删掉即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认有axis = 0,即对整行进行操作</span></span><br><span class="line">data = data.dropna()</span><br></pre></td></tr></table></figure></li><li><strong>类型转换</strong><br>假设我们有一特征<u>楼层(floor)</u>：有first，second，third 三个string值，将其转化为0，1，2。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以得到[&quot;first&quot;,&quot;second&quot;,third]</span></span><br><span class="line">labels = data[<span class="string">&quot;floor&quot;</span>].unique().tolist()</span><br><span class="line"><span class="comment">#index可以返回元素x在列表中的位置</span></span><br><span class="line">data[<span class="string">&quot;floor&quot;</span>] = data[<span class="string">&quot;floor&quot;</span>].apply( <span class="keyword">lambda</span> x : labels.index(x))</span><br></pre></td></tr></table></figure><blockquote><ul><li>关于apply()的具体用法<a class="link"   href="https://blog.csdn.net/anshuai_aw1/article/details/82347016" >见此<i class="fas fa-external-link-alt"></i></a></li></ul></blockquote></li><li><strong>语法补充</strong><br>上述我们一直在使用的<strong>data</strong>是pandas特有的<strong>DataFrame</strong>类型，关于取出其中的某一列特征进行操作可以使用<code>data[&quot;age&quot;]</code>，但最好使用<code>data.loc[:,&quot;age&quot;]</code>或是<code>data.iloc[:,3]</code>。</li></ol><h3 id="分离特征-x-与标签-y"><a href="#分离特征-x-与标签-y" class="headerlink" title="分离特征(x)与标签(y)"></a>分离特征(x)与标签(y)</h3><p>假设我们要取出的标签是<u>楼层(floor)</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = data.iloc[:, data.colums !=<span class="string">&quot;floor&quot;</span>]</span><br><span class="line">y = data.iloc[:, data.colums == <span class="string">&quot;floor&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="划分训练集与测试集"><a href="#划分训练集与测试集" class="headerlink" title="划分训练集与测试集"></a>划分训练集与测试集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取30%为测试集，70%为训练集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtext, Ytrain, Ytest = train_test_split(x, y, test_size = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>此函数随机选取训练集与测试集，会将索引打乱，为了以防万一对后续造成额外影响，有必要纠正索引.</p><blockquote><ul><li>所谓”索引“，是pandas在导入时DataFrame对每一行数据按顺序产生的索引,当输入<code>Xtrain.index</code>时会返回被打乱的索引列表。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#恢复索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [Xtrain, Xtext, Ytrain, Ytest] ： </span><br><span class="line">    i.index = <span class="built_in">range</span>(i.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(random_state = <span class="number">25</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)<span class="comment">#R方</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li><strong>交叉验证</strong> : 指不断随机改变训练集与测试集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10次交叉验证均值</span></span><br><span class="line">cross_score = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br></pre></td></tr></table></figure></li></ul><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><ul><li><strong>基础方法</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tr = []<span class="comment">#训练集拟合程度</span></span><br><span class="line">te = []<span class="comment">#测试集拟合程度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) : </span><br><span class="line"><span class="comment">#调整max_depth，即剪枝</span></span><br><span class="line">    clf = DecisionTreeClassifier(random_state = <span class="number">25</span>, max_depth = i + <span class="number">1</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">    clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">    score_tr = clf.score(Xtest, Ytest)</span><br><span class="line">    score_te = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br><span class="line">    tr.append(score_tr)</span><br><span class="line">    te.append(score_te)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), tr, color = <span class="string">&quot;red&quot;</span>, label = <span class="string">&quot;train&quot;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), te, color = <span class="string">&quot;blue&quot;</span>,label = <span class="string">&quot;test&quot;</span>)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.legend()</span><br><span class="line">ply.show()</span><br></pre></td></tr></table></figure></li><li><strong>网格搜索</strong><br>事实上就是暴力枚举，速度特别慢<br><del>(而且算了半天说不定还没一开始简简单单的好)</del><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parameters = &#123;<span class="string">&quot;criterion&quot;</span>:(<span class="string">&quot;gini&quot;</span>,<span class="string">&quot;entropy&quot;</span>), </span><br><span class="line">                        <span class="string">&quot;spliter&quot;</span>:(<span class="string">&quot;best&quot;</span>,<span class="string">&quot;random&quot;</span>),</span><br><span class="line">                        <span class="string">&quot;max_depth&quot;</span>: [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)],</span><br><span class="line">                        <span class="string">&quot;min_samples_leaf&quot;</span> = [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>,<span class="number">5</span>)],</span><br><span class="line">                        <span class="string">&quot;min_impurity_decrease&quot;</span> = np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">50</span>) &#125;</span><br><span class="line">clf = DecisionTreeClassifier(random = <span class="number">25</span>)</span><br><span class="line">GS = GridSearchCV(clf, parameters, cv = <span class="number">10</span>)</span><br><span class="line">GS = GS.fit(Xtrain, Ytrain)</span><br><span class="line">GS.best_params_<span class="comment">#最佳参数组合</span></span><br><span class="line">GS.best_score_<span class="comment">#最佳结果r方</span></span><br></pre></td></tr></table></figure><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3>生成可视化图,在这里仅仅只能输出一个dot文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot_data = export_graphviz(tree,out_file= <span class="string">&quot;result.dot&quot;</span>,class_names[<span class="string">&#x27;serious&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>],feature_names=cancer.feature_names,impurity=<span class="literal">False</span>,filled=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>将.dot文件转为jpg文件，展示可视化图(不知道为啥不可用，要用cmd来转换 <code>dot result.dot -T jpg -o result.jpg)</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(graph,)= pydot.graph_from_dot_file(<span class="string">&#x27;result.dot&#x27;</span>)</span><br><span class="line">graph.write_png(<span class="string">&#x27;tree.png&#x27;</span>)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210125183759997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn决策树&quot;&gt;&lt;a href=&quot;#sklearn决策树&quot; class=&quot;headerlink&quot; title=&quot;sklearn决策树&quot;&gt;&lt;/a&gt;sklearn决策树&lt;/h1&gt;&lt;h3 id=&quot;参数表示&quot;&gt;&lt;a href=&quot;#参数表示&quot; class=&quot;head</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklean" scheme="http://example.com/tags/sklean/"/>
    
    <category term="决策树" scheme="http://example.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(6)PairGrid</title>
    <link href="http://example.com/2021/11/02/seaborn6/"/>
    <id>http://example.com/2021/11/02/seaborn6/</id>
    <published>2021-11-01T17:27:36.000Z</published>
    <updated>2021-11-01T17:29:25.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-6-PairGrid"><a href="#seaborn入门-6-PairGrid" class="headerlink" title="seaborn入门(6)PairGrid"></a>seaborn入门(6)PairGrid</h1><h2 id="PairGrid"><a href="#PairGrid" class="headerlink" title="PairGrid"></a>PairGrid</h2><p>代码和图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">iris_g = sns.PairGrid(iris,hue = <span class="string">&quot;species&quot;</span>)</span><br><span class="line">iris_g.<span class="built_in">map</span>(plt.scatter)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130001248178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>累了，溜了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-6-PairGrid&quot;&gt;&lt;a href=&quot;#seaborn入门-6-PairGrid&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(6)PairGrid&quot;&gt;&lt;/a&gt;seaborn入门(6)PairGrid&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(5)群图(cluster map)</title>
    <link href="http://example.com/2021/11/02/seaborn5/"/>
    <id>http://example.com/2021/11/02/seaborn5/</id>
    <published>2021-11-01T17:25:33.000Z</published>
    <updated>2021-11-01T17:27:18.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-5-群图-cluster-map"><a href="#seaborn入门-5-群图-cluster-map" class="headerlink" title="seaborn入门(5)群图(cluster map)"></a>seaborn入门(5)群图(cluster map)</h1><h2 id="群图-cluster-map"><a href="#群图-cluster-map" class="headerlink" title="群图(cluster map)"></a>群图(cluster map)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">species = iris.pop(<span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(species)</span><br><span class="line">sns.clustermap(iris)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129233342616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>这图可能有亿点点复杂，但其实很简单(<del>并不是</del>)<br>这就是所谓的<strong>分层聚类热图</strong>，首先计算了点与点之间的距离，最接近的会被加入，然后开始比较行与列之间的关系。（<del>说了个几把</del> ）</p><p><strong>让我们稍微换一个简单一点点的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">sns.clustermap(flights,cmap = <span class="string">&quot;Blues&quot;</span>, standard_scale=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>flights代表的是一个二维数组，代表某年某月的乘客人数，<a class="link"   href="https://blog.csdn.net/newsunson/article/details/113408300" >详情见<i class="fas fa-external-link-alt"></i></a></p><p>所以我们得到下面的图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129234934427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>你会发现年份和月份并不是按着顺序排列的，这其实就是一个相当于聚类的过程，你可以把他看成一个聚类后的热力图（<strong>我以为我懂了，仔细一想我好像还是有点懵，希望大佬们来补充一下</strong>）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-5-群图-cluster-map&quot;&gt;&lt;a href=&quot;#seaborn入门-5-群图-cluster-map&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(5)群图(cluster map)&quot;&gt;&lt;/a&gt;seaborn</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(4)关联系数矩阵和热力图</title>
    <link href="http://example.com/2021/11/02/seaborn4/"/>
    <id>http://example.com/2021/11/02/seaborn4/</id>
    <published>2021-11-01T17:24:29.000Z</published>
    <updated>2021-11-01T17:26:51.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-4-关联系数矩阵和热力图"><a href="#seaborn入门-4-关联系数矩阵和热力图" class="headerlink" title="seaborn入门(4)关联系数矩阵和热力图"></a>seaborn入门(4)关联系数矩阵和热力图</h1><h2 id="关联系数矩阵"><a href="#关联系数矩阵" class="headerlink" title="关联系数矩阵"></a>关联系数矩阵</h2><p>这个懂的都懂，大概就是表示两个变量之间的关联性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">tips_mx = tips_df.corr()</span><br><span class="line"><span class="built_in">print</span>(tips_df.corr())</span><br></pre></td></tr></table></figure><p>载入数据有问题看seaborn入门(1)<br>得到如下结果<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230000142.png#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h2><p>我们可以将上面的矩阵可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.heatmap(tips_mx,annot = <span class="literal">True</span> , cmap = <span class="string">&#x27;Blues&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>其中cmap的选择和<a class="link"   href="https://editor.csdn.net/md/?articleId=113408019" >调色盘<i class="fas fa-external-link-alt"></i></a>一样</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230758969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="酷酷的热力图"><a href="#酷酷的热力图" class="headerlink" title="酷酷的热力图"></a>酷酷的热力图</h2><p>我们采用新的数据，并创建一个数据透视图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(name=<span class="string">&#x27;flights&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line"><span class="comment">#数据透视图创建</span></span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原来的数据是这样的<img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232036805.png#pic_center"                      alt="在这里插入图片描述"                ><br>数据透视图是这样的，表示某年某月某日乘坐飞机的人数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129231848465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>画成热力图就是<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232302523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br><del>有种马赛克的美感</del> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-4-关联系数矩阵和热力图&quot;&gt;&lt;a href=&quot;#seaborn入门-4-关联系数矩阵和热力图&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(4)关联系数矩阵和热力图&quot;&gt;&lt;/a&gt;seaborn入门(4)关联系数矩阵和热</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(3)调色盘</title>
    <link href="http://example.com/2021/11/02/seaborn3/"/>
    <id>http://example.com/2021/11/02/seaborn3/</id>
    <published>2021-11-01T17:22:20.000Z</published>
    <updated>2021-11-01T17:25:19.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-3-调色盘"><a href="#seaborn入门-3-调色盘" class="headerlink" title="seaborn入门(3)调色盘"></a>seaborn入门(3)调色盘</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><p>续接上文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">sns.set_context(<span class="string">&#x27;talk&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="调色盘"><a href="#调色盘" class="headerlink" title="调色盘"></a>调色盘</h2><p>访问这个界面你能看到调色看给你的一些风格样式<br><code>https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html</code><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129224410260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>例如我选一个夏天风情的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df,jitter = <span class="literal">True</span>,hue = <span class="string">&#x27;sex&#x27;</span>,palette = <span class="string">&#x27;summer&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129225343154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-3-调色盘&quot;&gt;&lt;a href=&quot;#seaborn入门-3-调色盘&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(3)调色盘&quot;&gt;&lt;/a&gt;seaborn入门(3)调色盘&lt;/h1&gt;&lt;h2 id=&quot;基础准备&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
</feed>
