<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-25T06:41:16.010Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>视觉进阶培训1-运动预测</title>
    <link href="http://example.com/2021/11/25/rm-train-1/"/>
    <id>http://example.com/2021/11/25/rm-train-1/</id>
    <published>2021-11-25T06:38:58.000Z</published>
    <updated>2021-11-25T06:41:16.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视觉进阶培训1-运动预测"><a href="#视觉进阶培训1-运动预测" class="headerlink" title="视觉进阶培训1-运动预测"></a>视觉进阶培训1-运动预测</h1><p>三维弹球，准确的来说有点像气体分子的运动，可以看成空间中有一个小球（无重力），以随机的速度在空间中游动，碰到边缘会反弹，而你要做的就是预测小球一定时间之后的位置。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><p>numpy 1.20</p></li><li><p>ros melodic</p></li><li><p>Eigen </p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/newsun-boki/3dBall.git</span><br><span class="line"><span class="built_in">cd</span> 3dBall</span><br><span class="line">catkin_make <span class="comment"># rm -rf ./build ./devel if exits</span></span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#记得每打开一个终端都要source一下</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line"></span><br><span class="line">rosrun random_ball simu.py <span class="comment">#用于生成小球</span></span><br><span class="line"></span><br><span class="line">rosrun random_ball basic_shapes <span class="comment">#用于生成绿色框</span></span><br><span class="line"></span><br><span class="line">rviz -d src/random_ball/rm.rviz <span class="comment">#在rviz中显示</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/ball.6tt9rynnjeo0.gif"                                     ></p><h2 id="任务说明"><a href="#任务说明" class="headerlink" title="任务说明"></a>任务说明</h2><h3 id="必要知识"><a href="#必要知识" class="headerlink" title="必要知识"></a>必要知识</h3><ul><li>c++/python基础知识</li><li>了解ros的topic机制</li><li>了解rviz的使用</li><li>卡尔曼滤波(KF)或扩展卡尔曼滤波(EKF)或抗差卡尔曼滤波(UKF)<h3 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h3></li></ul><p>已知小球小球当前时刻的三维坐标，预测小球一定时间之后所处的位置(反弹部分不作要求)。节点图如下。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-22-34.1hdjhcrer068.png"                      alt="节点图"                ></p><ul><li>节点<code>/basic_shapes</code>用于发布<code>/visualization_marker</code>话题，即绿色边界框。</li><li>节点<code>/random_ball</code>用于发布<code>/position</code>话题，即小球的位置。<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3></li></ul><h4 id="获取小球当前位置。"><a href="#获取小球当前位置。" class="headerlink" title="获取小球当前位置。"></a>获取小球当前位置。</h4><ul><li>当运行<code>rosrun random_ball simu.py</code>后，通过<code>rostopic list</code>可以查询到有小球当前位置话题<code>/position</code>。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-27-19.10uiu20b9brk.png"                                     ></li><li>发送内容为<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-29-11.1lyv1ga20kio.png"                                     ></li><li>发送的消息格式为<code>geometry_msgs/PointStamped</code>，关于数据格式的了解见roswiki。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-34-34.75bszbno3iw0.png"                                     ></li><li>发送频率大概是450hz<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-13-28-44.6s1gt3r2c3w0.png"                                     ></li></ul><p>这里需要重新写一个<strong>预测节点</strong>，并在节点内创建一个<code>Subscriber</code>用于订阅<code>/position</code>话题。</p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>使用各种卡尔曼滤波(如EKF)的手段进行<strong>预测</strong>。通过小球之前的位置预测小球一段时间之后的位置，具体预测多久可自行决定。这里需要你学习一些卡尔曼的相关知识，使用Eigen库辅助来完成一些数学运算，尽量不要使用opencv自带的卡尔曼滤波。推荐B站DR_CAN的卡尔曼滤波相关<a class="link"   href="https://www.bilibili.com/video/BV1ez4y1X7eR" >讲解视频<i class="fas fa-external-link-alt"></i></a>.但注意简单的卡尔曼是线性的，所以需要用一些如扩展卡尔曼等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211125/Screenshot-from-2021-11-25-14-19-03.49vp6ibwwqm0.png"                                     ><br>虽然卡尔曼是一个滤波算法，但由于其方法特性同样可以用来做预测。还有一个卡尔曼用于<a class="link"   href="https://www.bilibili.com/video/BV1dQ4y1m7ZC" >预测小球的讲解视频<i class="fas fa-external-link-alt"></i></a>(这个视频给了我这次任务灵感，虽然我并没有看)</p><h4 id="RVIZ显示"><a href="#RVIZ显示" class="headerlink" title="RVIZ显示"></a>RVIZ显示</h4><p>这里你需要大概了解rviz的使用方法。rviz可以接受话题里的消息并将其显示出来，你需要做的就是将你预测的结果发布为<code>PointStamped</code>格式并使用rviz显示，如果不了解结果可以参考<code>simu.py</code>里的实现。将<strong>你的预测结果用换一个颜色的小球显示出来</strong>就好。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li><code>rosrun random_ball simu.py</code>这个命令<code>ctrl+c</code>似乎停不下来，你可以使用<code>ctrl+z</code>将其挂到后台暂停它,然后通过<code>jobs</code>查看后台任务,并使用<code>kill %num</code>杀死它，<code>num</code>为其在<code>jobs</code>查看时任务对应的序号。</li><li>由于物体是随机运动，所以预测一段之后的时间不能过长，当然也不能过短。至于是多少，你看着觉得多少合适就多少。</li><li>评价预测好坏主要有两个指标<ul><li> <strong>收敛速度</strong>。包括当小球从静止到运动需要多久才能开始准确预测，以及当小球撞击边缘速度发生突变时尽量收敛到正确方向的时间(可以采取一些如当检测速度突变就reset卡尔曼的手段)</li><li> <strong>预测结果的稳定性</strong>。在实际控制当中，为了使电机不震颤，视觉的预测结果需要尽量的平滑稳定，即预测点不要乱抖。</li></ul></li><li>如果你觉的这个弹球模型好玩，并且看懂了弹球代码，你可以编写<code>simu.py</code>程序自己往里面多加几个球并加上物理体积的碰撞。或者我一总觉得这个碰到边缘没有音效怪怪的，你可以自己往里面加点音效。</li><li>为了方便查看，这个README我也会发到博客上。<ul><li>gitee：<a class="link"   href="https://gitee.com/newsun-boki/Ball3d" >https://gitee.com/newsun-boki/Ball3d<i class="fas fa-external-link-alt"></i></a></li><li>github:<a class="link"   href="https://github.com/newsun-boki/3dBall" >https://github.com/newsun-boki/3dBall<i class="fas fa-external-link-alt"></i></a></li><li>博客： </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视觉进阶培训1-运动预测&quot;&gt;&lt;a href=&quot;#视觉进阶培训1-运动预测&quot; class=&quot;headerlink&quot; title=&quot;视觉进阶培训1-运动预测&quot;&gt;&lt;/a&gt;视觉进阶培训1-运动预测&lt;/h1&gt;&lt;p&gt;三维弹球，准确的来说有点像气体分子的运动，可以看成空间中有一</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
    <category term="predict" scheme="http://example.com/tags/predict/"/>
    
    <category term="rviz" scheme="http://example.com/tags/rviz/"/>
    
  </entry>
  
  <entry>
    <title>KoroFileHeader-Vscode自动注释插件推荐</title>
    <link href="http://example.com/2021/11/22/KoroFileHeader/"/>
    <id>http://example.com/2021/11/22/KoroFileHeader/</id>
    <published>2021-11-22T14:55:16.000Z</published>
    <updated>2021-11-22T15:38:24.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KoroFileHeader-Vscode自动注释插件推荐"><a href="#KoroFileHeader-Vscode自动注释插件推荐" class="headerlink" title="KoroFileHeader-Vscode自动注释插件推荐"></a>KoroFileHeader-Vscode自动注释插件推荐</h1><p>写代码时注释是十分必要的，一个没有注释的代码几乎没人能看懂==屎山。</p><p>但是不得不说写注释是真的麻烦，而且我想写出一个好看一点的注释，让看得人也能赏心悦目，我就在想vscode有没有这么一款插件可以自动添加注释，结果您猜怎么着？还真有。</p><h2 id="KoroFileHeader-一款注释插件"><a href="#KoroFileHeader-一款注释插件" class="headerlink" title="KoroFileHeader-一款注释插件"></a>KoroFileHeader-一款注释插件</h2><ul><li>可用于代码段头的添加如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: liboyu </span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-Mo 10:48:22 </span></span><br><span class="line"><span class="comment"> * @Last Modified by:   liboyu </span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-11-Mo 10:48:22 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>也可以为函数添加注释,而且能够自动识别形参，你只需要把注释写在对应形参和返回值后就好啦</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @description: 初始化函数</span></span><br><span class="line"><span class="comment">    * @param &#123;string&#125; xml_path                     openvino模型的地址</span></span><br><span class="line"><span class="comment">    * @param &#123;double&#125; cof_threshold                置信度阈值</span></span><br><span class="line"><span class="comment">    * @param &#123;double&#125; nms_area_threshold           nms的iou重合面积阈值</span></span><br><span class="line"><span class="comment">    * @param &#123;int&#125; _class_number                   总共的类数</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(string xml_path,<span class="keyword">double</span> cof_threshold,<span class="keyword">double</span> nms_area_threshold,<span class="keyword">int</span> _class_number)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在vscode应用商店搜索KoroFileHeader安装。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>头部标注添加：快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i, linux: ctrl+meta+i,Ubuntu: ctrl+super+i</li><li>函数注释添加：快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t,linux: ctrl+meta+t, Ubuntu: ctrl+super+t</li></ul><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p><strong>这竟然还能一键添加各种奇奇怪怪的东西，这才是这个插件的精髓</strong>(如果你看网页源码的话会发现我也添加了一个小东西)<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://github.com/OBKoro1/koro1FileHeader/raw/master/images/codeDesign.gif?raw=true"                                     ></p><!-- * _______________#########_______________________  * ______________############_____________________  * ______________#############____________________  * _____________##__###########___________________  * ____________###__######_#####__________________  * ____________###_#######___####_________________  * ___________###__##########_####________________  * __________####__###########_####_______________  * ________#####___###########__#####_____________  * _______######___###_########___#####___________  * _______#####___###___########___######_________  * ______######___###__###########___######_______  * _____######___####_##############__######______  * ____#######__#####################_#######_____  * ____#######__##############################____  * ___#######__######_#################_#######___  * ___#######__######_######_#########___######___  * ___#######____##__######___######_____######___  * ___#######________######____#####_____#####____  * ____######________#####_____#####_____####_____  * _____#####________####______#####_____###______  * ______#####______;###________###______#________  * ________##_______####________####______________  -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KoroFileHeader-Vscode自动注释插件推荐&quot;&gt;&lt;a href=&quot;#KoroFileHeader-Vscode自动注释插件推荐&quot; class=&quot;headerlink&quot; title=&quot;KoroFileHeader-Vscode自动注释插件推荐&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
    <category term="vscode" scheme="http://example.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04录屏并生成gif图片</title>
    <link href="http://example.com/2021/11/18/ubuntu-record-sc/"/>
    <id>http://example.com/2021/11/18/ubuntu-record-sc/</id>
    <published>2021-11-17T17:47:51.000Z</published>
    <updated>2021-11-17T17:49:57.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu18-04录屏并生成gif图片"><a href="#Ubuntu18-04录屏并生成gif图片" class="headerlink" title="Ubuntu18.04录屏并生成gif图片"></a>Ubuntu18.04录屏并生成gif图片</h1><p>用kazam录屏ffmpeg转gif</p><p>标记一下这篇文章，以免我忘了每次都要去找：</p><p><a class="link"   href="https://blog.csdn.net/RedKeyer/article/details/89519984" >https://blog.csdn.net/RedKeyer/article/details/89519984<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu18-04录屏并生成gif图片&quot;&gt;&lt;a href=&quot;#Ubuntu18-04录屏并生成gif图片&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu18.04录屏并生成gif图片&quot;&gt;&lt;/a&gt;Ubuntu18.04录屏并生成gif图片&lt;/</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ROS新手介绍</title>
    <link href="http://example.com/2021/11/18/ros-begin/"/>
    <id>http://example.com/2021/11/18/ros-begin/</id>
    <published>2021-11-17T17:21:42.000Z</published>
    <updated>2021-11-17T19:05:45.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS介绍"><a href="#ROS介绍" class="headerlink" title="ROS介绍"></a>ROS介绍</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里只是ROS的基础入门的开始，做一个非常简单的讲解。</p><p>一般建议直接看官方文档：<a class="link"   href="http://wiki.ros.org/cn/ROS/Tutorials" >http://wiki.ros.org/cn/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>.</p><p>强烈建议看英文版：<a class="link"   href="http://wiki.ros.org/en/ROS/Tutorials" >http://wiki.ros.org/en/ROS/Tutorials<i class="fas fa-external-link-alt"></i></a>. 能够培养你阅读外的能力，毕竟大多数官方教程和写的好的教程是没有中文的。</p><h2 id="什么是ROS，为什么要用ROS"><a href="#什么是ROS，为什么要用ROS" class="headerlink" title="什么是ROS，为什么要用ROS"></a>什么是ROS，为什么要用ROS</h2><p>ROS的全称是<strong>Robot Operating System</strong>，也就是指<strong>机器人操作系统</strong>。但什么才是一个操作系统呢?想想现在都有些什么操作系统，Windows,linux,mac,Android等等，甚至你可能听过DOS系统，一个操作系统的基本特征有些什么呢？为什么ROS可以称为一个操作系统。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/ros.1xue58m21bj4.gif"                                     ></p><h3 id="分布式架构以及多进程"><a href="#分布式架构以及多进程" class="headerlink" title="分布式架构以及多进程"></a>分布式架构以及多进程</h3><p>想想你的Windows系统，你可以一边打游戏，一边看qq，后台还可能挂着杀毒软件，这些都是一个一个进程。一个操作系统运行往往包含大量的进程，但想想你写出来的代码，他可能是按着顺序来的，可能你把它放一个while循环里让他来回跑，或者你也可以多开几个线程让他分别跑着，但是这样还不够。</p><p>一个机器人，可能和人一样，有着眼睛(摄像头取流以及视觉目标检测),有着手(机械臂模块),脚(不同的底盘),还有着很多东西。这些东西光通讯就是一个大问题，更不要说让他们之间尽量互不干扰，但ros可以做到。就像你聊qq不耽误你打游戏一样。<strong>也就是说，在ros上，你实际上是可以运行多个程序，并且能够做到让这些程序间的数据互传。</strong></p><p>事实上，你也可以在其他的操作系统上做到这一点，例如通过SOCKER,管道，TCP协议等，但都没有ros方便快捷清晰。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-11-39.638zlyali1c0.png"                                     ></p><h3 id="功能的划分以及极强的可扩展性"><a href="#功能的划分以及极强的可扩展性" class="headerlink" title="功能的划分以及极强的可扩展性"></a>功能的划分以及极强的可扩展性</h3><p>在不用ros的时候，想想机器人是怎么控制的。冗长的代码，看不懂的结构，更是因为模块众多导致的代码量大，往往不知所措。然而有了ros，一切都不一样了。你可以把每个功能的模块分开，这里的分开不是简单的封装到一个个函数里。而是完全的分开，即多个不同的功能包，多个不同的代码，唯一的连接就是一些消息间的互传。这使得每一个模块结构清晰简单，代码可读性增强，且可扩展性极强。</p><h3 id="良好的生态"><a href="#良好的生态" class="headerlink" title="良好的生态"></a>良好的生态</h3><p>由于ROS得到越来越多机器人制作者的青睐，越来越多的机器人相关硬件软件抖做了ros适配的相关工作。就和Windows上的游戏支持比mac上多的多一样，很多时候你买到游戏没有Windows寸步难行。同样由于很多硬件如激光雷达等对ROS的支持,没有ros寸步难行。良好的生态也决定促使ros愈发蓬勃发展，现如今，ros里集成的大量的库，你可以用它来做slam定位建图导航，也可以用它来做自动驾驶汽车，还有利用第三方软件Gazebo模拟仿真等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211118/Screenshot-from-2021-11-18-02-10-30.6000i1mywqg0.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ROS介绍&quot;&gt;&lt;a href=&quot;#ROS介绍&quot; class=&quot;headerlink&quot; title=&quot;ROS介绍&quot;&gt;&lt;/a&gt;ROS介绍&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>图片上传网络</title>
    <link href="http://example.com/2021/11/15/picx/"/>
    <id>http://example.com/2021/11/15/picx/</id>
    <published>2021-11-14T19:03:51.000Z</published>
    <updated>2021-11-14T19:36:46.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="picx图片上传网络"><a href="#picx图片上传网络" class="headerlink" title="picx图片上传网络"></a>picx图片上传网络</h1><p>在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，这个时候一般的选择是先将图片上传到github/gitee或csdn然后再使用网络链接，但还是不够方便，并且github需要翻墙才能看的问题，有个国人大佬就开发了一个名叫<strong>picx</strong>的东西。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/Screenshot-from-2021-11-15-03-07-58.5jhahkkrhcs0.png"                                     ><br>上面这界面就是使用picx上传的，本质上他还是借用了你自己的github仓库去放图片，然而它使用一个叫CDN加速的东西让你的图片可以很快的显示。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>github仓库:<a class="link"   href="https://github.com/XPoet/picx" >https://github.com/XPoet/picx<i class="fas fa-external-link-alt"></i></a></li><li>picx网页地址:<a class="link"   href="https://picx.xpoet.cn/#/upload" >https://picx.xpoet.cn/#/upload<i class="fas fa-external-link-alt"></i></a></li></ul><p>去github仓库看README教你如何在picx网页上配置，记得一定要使用生成的CDN加速的链接，否则就没有意义了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;picx图片上传网络&quot;&gt;&lt;a href=&quot;#picx图片上传网络&quot; class=&quot;headerlink&quot; title=&quot;picx图片上传网络&quot;&gt;&lt;/a&gt;picx图片上传网络&lt;/h1&gt;&lt;p&gt;在用markdown写博客上传网页时常常会涉及本地图片无法在网络显示的问题，</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
    <category term="markdown" scheme="http://example.com/tags/markdown/"/>
    
    <category term="blog" scheme="http://example.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>livox-mid70激光雷达使用实录</title>
    <link href="http://example.com/2021/11/14/livox-detection/"/>
    <id>http://example.com/2021/11/14/livox-detection/</id>
    <published>2021-11-14T14:50:48.000Z</published>
    <updated>2021-11-14T19:36:52.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="livox-mid70激光雷达使用实录"><a href="#livox-mid70激光雷达使用实录" class="headerlink" title="livox-mid70激光雷达使用实录"></a>livox-mid70激光雷达使用实录</h1><p>livox-mid70是由大疆发布的面阵激光雷达，是大疆为自动驾驶推出的一款激光雷达，同时也可用于建立三维地图，文物修复，与大疆无人机相结合使用。你可以在x86和arm架构上都可以使用(arm需要交叉编译)。<br>bilibili上Livox官方发布了大量的视频demo可以去围观一下，同时Livox也有一个论坛可以去看一下。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a class="link"   href="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html" >https://livox-wiki-cn.readthedocs.io/zh_CN/latest/index.html<i class="fas fa-external-link-alt"></i></a><br>这是中文官方文档，请根据以上文档完成硬件上的连接以及Ip配置，一切以官方文档为主。</p><ul><li>硬件连接</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/one_lidar_connect.png"                                     ></p><ul><li><p>更改IP：一般来说刚拿到手都是<strong>静态IP</strong>，这时候你只需要将网线与你自己笔记本相连，然后通过用户手册查看你自己雷达的IP，那需要设置你自己电脑的IP为手动，并将其分在同一网段不同的地址下：</p><pre><code>  如我的Mid70的IP地址为192.168.1.105，  那么我电脑设置时  IP：192.168.1.104，  子网掩码：255.255.255.0,  网关：192.168.0.1</code></pre></li></ul><p>如果对IP配置有问题,或想改为动态IP详情参见<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Mid%20Series%20User%20Manual%20(CN).pdf" >用户手册<i class="fas fa-external-link-alt"></i></a></p><h2 id="Livox-Viewer"><a href="#Livox-Viewer" class="headerlink" title="Livox Viewer"></a>Livox Viewer</h2><p>Livox Viewer是一款图形化操作的显示软件，有助于快速让你知道你的硬件连接和Ip配置有没有问题。</p><ul><li><a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/update/Livox%20Viewer%200.8.0.7z" >Livox-Viewer for Windows<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.livoxtech.com/3296f540ecf5458a8829e01cf429798e/downloads/Livox%20Viewer/Livox_Viewr_For_Linux_Ubuntu16.04_x64_0.7.0.tar.gz" >Livox-Viewer for ubuntu16.04<i class="fas fa-external-link-alt"></i></a>,下载后解压运行<code>./livox viewer.sh</code>即可打开如下界面。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/_images/start_Viewer_and_link_Horizon.png"                                     ></li><li>官方软件Livox Viewer仅支持Windows或ubuntu16.04/14.04,所以建议如果不是这两个版本有ros可以直接上。</li></ul><h2 id="Livox-SDK"><a href="#Livox-SDK" class="headerlink" title="Livox-SDK"></a>Livox-SDK</h2><p>刚刚Livox Viewer只是一个快速尝试，如果你要做开发就<strong>必须</strong>要安装Livox-SDK(包括后面要在ros上使用也必须先要安装这个)</p><ul><li><p>github上中文<a class="link"   href="https://github.com/Livox-SDK/Livox-SDK/blob/master/README_CN.md" >README<i class="fas fa-external-link-alt"></i></a></p></li><li><p>先从github上clone下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/Livox-SDK.git</span><br></pre></td></tr></table></figure></li><li><p>再编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Livox-SDK</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>简单运行demo，注意这里的sample是在build文件夹下面的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sample/lidar &amp;&amp; ./lidar_sample</span><br></pre></td></tr></table></figure></li></ul><h2 id="livox-ros-driver"><a href="#livox-ros-driver" class="headerlink" title="livox-ros-driver"></a>livox-ros-driver</h2><p>不得不说ros是真的好用，所以建议在ros下使用，会使得一切都很清晰明了。装<code>livox-ros-driver</code>前必须要先装<code>Livox-SDK</code>。</p><ul><li><p>先从github上clone下来，这里一定要用下面这个命令把它clone到相应位置，否则会出问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src</span><br></pre></td></tr></table></figure></li><li><p>简单的<code>catkin_make</code>一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li><li><p>别忘了添加环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./devel/setup.sh</span><br></pre></td></tr></table></figure></li><li><p>之后跑个rviz的demo，让你的激光雷达点云数据在rviz里显示出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch</span><br></pre></td></tr></table></figure></li></ul><h2 id="录制你的点云数据"><a href="#录制你的点云数据" class="headerlink" title="录制你的点云数据"></a>录制你的点云数据</h2><p>点云数据不像二维图像一样，简简单单录制一个视频就好，作为点云数据记录是比较特殊的。<br>livox一共有两种录制格式</p><h4 id="lvx格式"><a href="#lvx格式" class="headerlink" title="lvx格式"></a>lvx格式</h4><p>lvx格式是livox的一种自定义格式，如果你想在Windows上快速录制，可以<strong>使用Livox Viewer进行录制</strong>，也可以<strong>通过<code>Livox-SDK</code>中的文件录制</strong></p><ul><li>首先进入以下路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./Livox_SDK/build/sample/lidar_lvx_file</span><br></pre></td></tr></table></figure></li><li>然后运行下面这个文件，这里不用<code>-c</code>指定也可以，这里指定了lidar并设定持续10s<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lidar_lvx_sample -c <span class="string">&quot;此处为已连接的Lidar的15位广播码&quot;</span> -t 10</span><br></pre></td></tr></table></figure>通过上面的操作会得到一个<code>.lvx</code>格式的文件，这个文件可以在Livox Viewer中直接播放，也可以转成<strong>rosbag</strong>(一个可以把ros中当前所有topic中message记录下来的东西)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver lvx_to_rosbag.launch lvx_file_path:=<span class="string">&quot;/home/livox/test.lvx&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="rosbag格式"><a href="#rosbag格式" class="headerlink" title="rosbag格式"></a>rosbag格式</h4><p>rosbag是ros中非常好用的一个东西，我在之前的ros文章中有提到过。当我们在运行livox-ros-driver中的rviz显示时，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch livox_ros_driver livox_lidar_rviz.launch <span class="comment">#详情看上面livox-ros-driver</span></span><br></pre></td></tr></table></figure><p>我们可以把此时的所有消息用rosbag记录下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -a -o myrosbag.bag <span class="comment">#-a代表所有的消息,-c代表输出名称</span></span><br></pre></td></tr></table></figure><p>此时就会生成一个.bag文件，具体名称看终端的输出。<br>你可以通过以下命令进行播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -l <span class="comment">#-l代表loop循环播放</span></span><br></pre></td></tr></table></figure><p>此时再打开在livox-ros-driver下的的rviz,就可以得到rosbag中的点云图了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ws_livox/src/livox_ros_driver/</span><br><span class="line">rviz -d config/display_lidar_points.rviz <span class="comment">#这种.rviz文件实际上是保存rviz相关显示的数据</span></span><br></pre></td></tr></table></figure><h2 id="livox-detection"><a href="#livox-detection" class="headerlink" title="livox_detection"></a>livox_detection</h2><p>livox_detection指的是激光点云检测，livox官方给的代码可以检测各种车和行人。官方说2080ti下需要50ms。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211115/demo1.4a7m388oo240.gif"                                     ></p><p>在Livox官方的github仓库中有两个激光点云检测仓库分别为<code>livox_detection</code>和<code>livox_dection_simu</code>。<br>这两个仓库看上去都差不多，但实际上非常坑的是：</p><ul><li><code>livox_detection</code>仓库中的预训练模型在可以识别人和车，但车的识别效果不是很好;</li><li><code>livox_dection_simu</code>仓库中的预训练模型只能识别车，而几乎无法识别到人(虽然代码看上去都差不多)。</li></ul><p>至于原因我也不知道，只是这坑了我一会儿，后来在issue发现了这个问题。</p><p>由于两个仓库操作都非常相似，这里选livox_detection_simu为例。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>python3.6+</li><li>tensorflow1.13+ (tested on 1.13.0)</li><li>pybind11(后面的过程中安装)</li><li>ros</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>首先clone仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Livox-SDK/livox_detection_simu</span><br></pre></td></tr></table></figure></li><li><p>然后配置pybind(pybind就是这样，每次都需要clone在那个路径下才行)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> livox_detection_simu/utils/lib_cpp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pybind/pybind11.git</span><br></pre></td></tr></table></figure></li><li><p>编译(在刚刚的<code>lib_cpp</code>路径下)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>把c++得到的依赖文件放到项目根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp lib_cpp.so ../../../</span><br></pre></td></tr></table></figure></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Download/dataset/livox_detection_simu_model.zip" >预训练模型<i class="fas fa-external-link-alt"></i></a>,会得到model文件夹，把它放在项目根目录下，这样你就不用改模型地址了,</p></li><li><p>下载<a class="link"   href="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/github/livox_detection_v1.1_data.zip" >rosbag<i class="fas fa-external-link-alt"></i></a>,这是官方提供的rosbag，你也可以自己录一个。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3></li><li><p>打开一个终端运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行rviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rviz -d ./config/show.rviz <span class="comment">#在livox_detection_simu仓库下</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端播放rosbag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play *.bag -r 0.1 <span class="comment">#找到你存放rosbag的路径运行，发送消息间隔0.1s</span></span><br></pre></td></tr></table></figure></li><li><p>打开一个终端运行目标检测程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python livox_detection_simu.py <span class="comment">#如果你的模型放在其他地方，你需要在config下将其模型路径改为你所放预训练模型的路径</span></span><br></pre></td></tr></table></figure></li></ul><p>由于目标检测速度相当慢，实时性非常差，队列里可能还缓存了很多帧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;a href=&quot;#livox-mid70激光雷达使用实录&quot; class=&quot;headerlink&quot; title=&quot;livox-mid70激光雷达使用实录&quot;&gt;&lt;/a&gt;livox-mid70激光雷达使用实录&lt;/h1&gt;&lt;p&gt;li</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="lidar" scheme="http://example.com/tags/lidar/"/>
    
  </entry>
  
  <entry>
    <title>在线文本对比</title>
    <link href="http://example.com/2021/11/09/text-compare-md/"/>
    <id>http://example.com/2021/11/09/text-compare-md/</id>
    <published>2021-11-09T05:59:46.000Z</published>
    <updated>2021-11-09T06:03:25.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线文本对比"><a href="#在线文本对比" class="headerlink" title="在线文本对比"></a>在线文本对比</h1><p>推荐一个在线快速对比文本区别的网站：</p><p><a class="link"   href="https://text-compare.com/" >https://text-compare.com/<i class="fas fa-external-link-alt"></i></a></p><p>可能会需要翻墙，但还挺好用。</p><p>不用下载可以直接对比，发个博客留作记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在线文本对比&quot;&gt;&lt;a href=&quot;#在线文本对比&quot; class=&quot;headerlink&quot; title=&quot;在线文本对比&quot;&gt;&lt;/a&gt;在线文本对比&lt;/h1&gt;&lt;p&gt;推荐一个在线快速对比文本区别的网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="website" scheme="http://example.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>ros基本操作</title>
    <link href="http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/11/03/ros%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-02T17:56:47.000Z</published>
    <updated>2021-11-09T05:58:41.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros基本操作"><a href="#ros基本操作" class="headerlink" title="ros基本操作"></a>ros基本操作</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>我们都知道话题机制是ros中必不可少的一个机制，那怎样查看我们所发布的话题呢</p><ul><li>list命令可以看到我们当前总共有哪些topic<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure></li><li>echo命令可以输出指定topic里的消息的内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo cmd_vel #cmd_vel是一个小海龟的速度topic</span><br></pre></td></tr></table></figure></li><li>hz命令可以计算指定topic消息发布的平均速率<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic hz cmd_vel</span><br></pre></td></tr></table></figure></li><li>info命令可以输出topic里的message的数据类型以及发布者接受者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic info cmd_vel</span><br></pre></td></tr></table></figure></li><li>rosmag show可以显示某个数据类型里具体的数据类型结构（注意这个和当前运行的程序没有关系）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg show geometry/Twist </span><br></pre></td></tr></table></figure>上面这个命令显示了geometry/Twist里包含的具体数据结构，如角速度(angular)xyz线速度(linear)xyz，geometry/Twist是cmd_vel这个topic里的消息的数据类型。</li></ul><h2 id="rqt"><a href="#rqt" class="headerlink" title="rqt"></a>rqt</h2><p>rqt是ros里可视化最基础的方式。</p><ul><li>rqt_graph可以显示出整个ros的分布式架构，包括节点，话题，服务等等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure></li><li>rqt_plot可以实时绘制出具体的话题里的消息里的一个或多个数据的变化曲线<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_plot cmd_vel/linear/x cmd_vel/angular/z</span><br></pre></td></tr></table></figure></li></ul><h2 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h2><p>rosbag可以记录消息，还可以重放消息。这对我们调试某个模块非常有帮助。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bagfiles</span><br><span class="line">rosbag record -a</span><br></pre></td></tr></table></figure><p>-a 选项表示将当前发布的所有 topic 数据都录制保存到一个 rosbag 文件中，录制的数据包名字为日期加时间。<br>也可以只记录某些感兴趣的 topic</p><ul><li>想要录制指定topic上的消息，你可以运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record cmd_vel</span><br></pre></td></tr></table></figure></li></ul><p>如果要指定生成数据包的名字，则用-O /-o 参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O filename.bag /topic_name1</span><br></pre></td></tr></table></figure><p>如果在 launch 文件中使用 rosbag record 命令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic1 /topic2&quot;/&gt; </span><br></pre></td></tr></table></figure><ul><li><p>rosbag info指令可以显示数据包中的信息:        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag info filename.bag</span><br></pre></td></tr></table></figure></li><li><p>rosbag play<br>接下来回放数据包中的 topic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果想改变消息的发布速率，可以用下面的命令，-r 后面的数字对应播放速率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -r 2 &lt;bagfile&gt;</span><br></pre></td></tr></table></figure><p>如果希望 rosbag 循环播放，可以用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -l  &lt;bagfile&gt;  # -l== --loop</span><br></pre></td></tr></table></figure><p>如果只播放感兴趣的 topic ，则用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play &lt;bagfile&gt; --topic /topic1</span><br></pre></td></tr></table></figure><p>在上述播放命令执行期间，空格键可以暂停播放。</p></li></ul><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p>这里我就不写了<br>精品博客：<a class="link"   href="http://ttshun.com/2018/05/24/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8Broslaunch/" >http://ttshun.com/2018/05/24/ROS学习之roslaunch/<i class="fas fa-external-link-alt"></i></a><br>来自励志献身slam的阿翔，里面有很多好的博文都可以去看一看，特别是slam相关的</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>未完待续，这里有一篇 比较详细的代码建议详细看一看：<a class="link"   href="http://ttshun.com/2018/03/22/ROS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%91%BD%E4%BB%A4/" >http://ttshun.com/2018/03/22/ROS学习之基本概念和命令/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros基本操作&quot;&gt;&lt;a href=&quot;#ros基本操作&quot; class=&quot;headerlink&quot; title=&quot;ros基本操作&quot;&gt;&lt;/a&gt;ros基本操作&lt;/h1&gt;&lt;h2 id=&quot;topic&quot;&gt;&lt;a href=&quot;#topic&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>rosserial进行串口通信</title>
    <link href="http://example.com/2021/11/02/rosserial/"/>
    <id>http://example.com/2021/11/02/rosserial/</id>
    <published>2021-11-01T17:56:47.000Z</published>
    <updated>2021-11-02T16:34:56.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rosserial进行串口通信"><a href="#rosserial进行串口通信" class="headerlink" title="rosserial进行串口通信"></a>rosserial进行串口通信</h1><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><ul><li>用于两个模块之间传输数据，是我们最常用的数据通信方式之一。包括单片机之间的通信，单片机与工控机之间的通信，单片机与外设模块之间的通信等等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-11-20.iyynbl97fo8.png"                      style="zoom:80%;"                 ><ul><li>由于 CPU 与接口之间按并行方式传输，接口与外设之间按串行方式传输，因此，在串行接口中，必须要有 “ 接收移位寄存器 “ （串→并）和 “ 发送移位寄存器 “ （并→串）.</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-16-55.67nf1dm75zk0.png"                      style="zoom: 67%;"                 ><ul><li>串口通讯是以高低电平为传输媒介，一位一位的传输，这一点是后面需要时刻牢记的。</li></ul><h3 id="具体发送的过程"><a href="#具体发送的过程" class="headerlink" title="具体发送的过程"></a>具体发送的过程</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/newsun-boki/img-folder@main/20211102/Screenshot-from-2021-11-02-02-21-41.3wv7h75f5fg0.png"                                     ></p><ul><li><p>波特率：传输速度的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数。如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。</p></li><li><p>数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包的数据位数，标准值是6、7和8位。比如，当我想发送一个uint8的整数，它就刚好能够完整发送。</p></li><li><p>我们只需要记住的是，串口一次只能发送8位二进制数，所以要发送和接受的数据是以8位二进制数的数组存储的，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> buffer[<span class="number">12</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h3><p>那既然我们一次只能发8位数字，那对于float这种32位的数字要怎么发呢？</p><p>答案是把它拆开为4个8位数字发出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">3.5</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f1 = (*((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;(x)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;                <span class="comment">//4个字节的float x转换为buffer中的4位</span></span><br><span class="line">        <span class="keyword">uint8_t</span> tmp = (f1 &gt;&gt; (<span class="number">8</span> * i)) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buffer[i] = tmp;                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看上去拆开的方法显然没有我们想的那么简单。</li><li>我们知道<code>float</code>的数据存储类型是比较复杂的，有尾数幂数等等巴拉巴拉。当我们把其拆分的时候会遇到许多问题，为了更好的运算，我们将其转换为无符号32位整数,即<code>unsigned int</code>。</li><li>仔细看上面的代码<code> unsigned int f1 = (*((unsigned int *)&amp;(x)))</code>，你可能会感觉很疑惑这行代码，但你细看或许就明白了。</li><li>实际上是把x的指针类型强行从<code>float</code>变成<code>unsigned int</code>。这样的好处是其在内存中的值不会变,那个二进制数还是那些，而我们直接使用类型转换实际上会改变其在内存中的值。</li></ul><p>同样再收到消息的时候我们也需要相同的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span> ; i--)&#123;            <span class="comment">//vertical pitch</span></span><br><span class="line">    hor += buffer[i];</span><br><span class="line">    <span class="keyword">if</span>(i) hor &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">yaw = (*((<span class="keyword">float</span>*)&amp;hor));</span><br></pre></td></tr></table></figure><h3 id="Ubuntu中串口通讯"><a href="#Ubuntu中串口通讯" class="headerlink" title="Ubuntu中串口通讯"></a>Ubuntu中串口通讯</h3><p>Ubuntu下的串口助手cutecom可以快速帮你查看是否有串口信号传入你的ubuntu。(虽然我之前并没有用过，使用方法也可以请教电控组成员或自行谷歌，如果不大行就算了吧)</p><ul><li><p>安装cutecom并打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cutecom</span><br><span class="line">sudo cutecom</span><br></pre></td></tr></table></figure></li><li><p>查看连接你电脑的串口信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev | grep ttyU* <span class="comment">#/dev路径下通常包含了所连外设，故要查看串口需要在这里进行查看，而grep是正则化，只查看名字是ttyU开头的文件</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyS* <span class="comment">#网上看到的，不知道行不行</span></span><br></pre></td></tr></table></figure><p>你可以通过拔插串口看哪一个设备改变从而确定设备名称。</p><p>详细的你可以看我随便找的一个链接：<a class="link"   href="https://blog.csdn.net/maizousidemao/article/details/103236666" >https://blog.csdn.net/maizousidemao/article/details/103236666<i class="fas fa-external-link-alt"></i></a></p></li></ul><h4 id="Ros中的串口通讯"><a href="#Ros中的串口通讯" class="headerlink" title="Ros中的串口通讯"></a>Ros中的串口通讯</h4><p>Ros使用rosserial包作为串口通信的方式</p><ol><li>首先下载rosserial</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-serial</span><br></pre></td></tr></table></figure><ul><li>进入安装位置确认是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd serial</span><br></pre></td></tr></table></figure><ul><li>若是成功则能够进入位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/melodic/share/serial</span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后创造工作空间,参照<a class="link"   href="https://blog.csdn.net/liuxiaodong400/article/details/88072502" >这个博客<i class="fas fa-external-link-alt"></i></a></p></li><li><p>创造功能包并编写以下代码</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serial_port.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;serial/serial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;serial_port&quot;</span>);</span><br><span class="line">    <span class="comment">//创建句柄（虽然后面没用到这个句柄，但如果不创建，运行时进程会出错）</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个serial类</span></span><br><span class="line">    serial::Serial sp;</span><br><span class="line">    <span class="comment">//创建timeout</span></span><br><span class="line">    serial::Timeout to = serial::Timeout::<span class="built_in">simpleTimeout</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//设置要打开的串口名称</span></span><br><span class="line">    sp.<span class="built_in">setPort</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>);</span><br><span class="line">    <span class="comment">//设置串口通信的波特率</span></span><br><span class="line">    sp.<span class="built_in">setBaudrate</span>(<span class="number">115200</span>);</span><br><span class="line">    <span class="comment">//串口设置timeout</span></span><br><span class="line">    sp.<span class="built_in">setTimeout</span>(to);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开串口</span></span><br><span class="line">        sp.<span class="built_in">open</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(serial::IOException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR_STREAM</span>(<span class="string">&quot;Unable to open port.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断串口是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(sp.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO_STREAM</span>(<span class="string">&quot;/dev/ttyUSB0 is opened.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取缓冲区内的字节数</span></span><br><span class="line">        <span class="keyword">size_t</span> n = sp.<span class="built_in">available</span>();</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//读出数据</span></span><br><span class="line">            n = sp.<span class="built_in">read</span>(buffer, n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//16进制的方式打印到屏幕</span></span><br><span class="line">                std::cout &lt;&lt; std::hex &lt;&lt; (buffer[i] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//把数据发送回去</span></span><br><span class="line">            sp.<span class="built_in">write</span>(buffer, n);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭串口</span></span><br><span class="line">    sp.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CmakeLists如下:</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(serial_com)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Compile as C++11, supported in ROS Kinetic and newer</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span> <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  OpenCV REQUIRED</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  serial</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Declare a C++ library</span></span><br><span class="line"><span class="comment"># add_library($&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment">#   src/$&#123;PROJECT_NAME&#125;/serial_com.cpp</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(stm_com</span><br><span class="line">  serial_port.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_dependencies</span>(stm_com <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(stm_com</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>运行roscore，运行节点看是否能打开串口。如果提示Unable to open port，是由于权限不够引起的，进行如下操作<br>创建文件:（若使用的是ttyACM将ttyusb替换即可）</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>udev<span class="regexp">/rules.d/</span><span class="number">70</span>-ttyusb.rules</span><br></pre></td></tr></table></figure><p>在打开的文件中添加</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KERNEL</span>==<span class="string">&quot;ttyUSB[0-9]*&quot;</span>, <span class="type">MODE</span>=<span class="string">&quot;0666&quot;</span></span><br></pre></td></tr></table></figure><p>或者直接更改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/ttyUSB*<span class="comment">#后面这个是你的串口设备</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rosserial进行串口通信&quot;&gt;&lt;a href=&quot;#rosserial进行串口通信&quot; class=&quot;headerlink&quot; title=&quot;rosserial进行串口通信&quot;&gt;&lt;/a&gt;rosserial进行串口通信&lt;/h1&gt;&lt;h2 id=&quot;串口通信&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="ros" scheme="http://example.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>从神经网络到深度学习</title>
    <link href="http://example.com/2021/11/02/mlbasic/"/>
    <id>http://example.com/2021/11/02/mlbasic/</id>
    <published>2021-11-01T17:50:00.000Z</published>
    <updated>2021-11-04T10:54:20.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从神经网络到深度学习"><a href="#从神经网络到深度学习" class="headerlink" title="从神经网络到深度学习"></a>从神经网络到深度学习</h1><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在之前我们已经介绍过了一些优化问题，然而并不是所有优化问题从输入到目标函数之间都有明确的公式。不如说，在生活中大部分时候我们都很难建立一个很准确的数学模型，同时也无法得知需要优化什么参数，特别是对于图片分类来说。例如，给你一张图片，让你分辨是猫还是狗。对于输入来说，我们有一张图片rgb三通道的所有值，而需要输出0或1分别代表猫和狗。为了解决这个问题，我们引入神经网络等相关一系列概念。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img2020.cnblogs.com/blog/1839046/202012/1839046-20201213200410529-875096804.png"                      alt="猫狗"                ></p><h2 id="机器学习-神经网络-深度学习"><a href="#机器学习-神经网络-深度学习" class="headerlink" title="机器学习 神经网络 深度学习"></a>机器学习 神经网络 深度学习</h2><p>首先，有必要对神经网络、深度学习、机器学习的概念做个简单描述。</p><p>神经网络，该模型灵感来自动物的中枢神经系统，通常呈现为相互连接的“神经元”，它可以对输入值通过反馈机制使得它们适应对应的输出。</p><p>深度学习是神经网络的进阶版，它的基本思路与神经网络类似，但往往比神经网络有着更复杂的结构以及优化算法，是神经网络的纵向延伸，常见的模型有CNN, RNN, LSTM等。</p><p>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>下面的图片很好地描述了这三者之间的关系</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://pic1.zhimg.com/80/v2-6d2584526f458fa512543d04ffb66c42_1440w.jpg?source=1940ef5c"                      alt="区别"                > </p><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><p><a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/1_ML_Basics.pdf" >ML<i class="fas fa-external-link-alt"></i></a></p><h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><p><strong>好的入门博文</strong>：<a class="link"   href="https://www.cnblogs.com/subconscious/p/5058741.html" >神经网络入门<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络实践与理解</strong>：<a class="link"   href="http://playground.tensorflow.org/" >tensorflow游乐场<i class="fas fa-external-link-alt"></i></a></p><p><strong>神经网络的详细理解</strong>：<a class="link"   href="https://b23.tv/c44LK8" >吴恩达神经网络<i class="fas fa-external-link-alt"></i></a></p><p><strong>自己的板书</strong>:<a class="link"   href="https://gitee.com/newsun-boki/XJTU_cource/blob/master/course3/ml_nn.pdf" >ml_nn<i class="fas fa-external-link-alt"></i></a></p><h2 id="pytorch的相关介绍"><a href="#pytorch的相关介绍" class="headerlink" title="pytorch的相关介绍"></a>pytorch的相关介绍</h2><p>pytorch是python的第三方库，是由facebook开源的神经网络框架，并有专门针对GPU加速模型训练的模块。与tensorflow不同，pytorch编程简洁，接口简单，且速度不逊色于其他框架，是当前神经网络最简洁，高效的实现方法之一。</p><p><strong>好的博文</strong>：<a class="link"   href="https://zhuanlan.zhihu.com/p/265394674?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=907670979105415168" >知乎pytorch<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从神经网络到深度学习&quot;&gt;&lt;a href=&quot;#从神经网络到深度学习&quot; class=&quot;headerlink&quot; title=&quot;从神经网络到深度学习&quot;&gt;&lt;/a&gt;从神经网络到深度学习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="rm" scheme="http://example.com/categories/rm/"/>
    
    
    <category term="rm" scheme="http://example.com/tags/rm/"/>
    
    <category term="machine leaning" scheme="http://example.com/tags/machine-leaning/"/>
    
  </entry>
  
  <entry>
    <title>sklearn决策树</title>
    <link href="http://example.com/2021/11/02/python-dt/"/>
    <id>http://example.com/2021/11/02/python-dt/</id>
    <published>2021-11-01T17:31:38.000Z</published>
    <updated>2021-11-01T17:34:28.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn决策树"><a href="#sklearn决策树" class="headerlink" title="sklearn决策树"></a>sklearn决策树</h1><h3 id="参数表示"><a href="#参数表示" class="headerlink" title="参数表示"></a>参数表示</h3><p>决策树中有<strong>参数</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DecisionTreeClassifier(criterion=<span class="string">&quot;gini&quot;</span></span><br><span class="line">           , splitter=<span class="string">&quot;best&quot;</span></span><br><span class="line">                    , max_depth=<span class="literal">None</span></span><br><span class="line">                    , min_samples_split=<span class="number">2</span></span><br><span class="line">                    , min_samples_leaf=<span class="number">1</span></span><br><span class="line">                    , min_weight_fraction_leaf=<span class="number">0.</span></span><br><span class="line">                    , max_features=<span class="literal">None</span></span><br><span class="line">                    , random_state=<span class="literal">None</span></span><br><span class="line">                    , max_leaf_nodes=<span class="literal">None</span></span><br><span class="line">                    , min_impurity_decrease=<span class="number">0.</span></span><br><span class="line">                    , min_impurity_split=<span class="literal">None</span></span><br><span class="line">                    , class_weight=<span class="literal">None</span>,</span><br><span class="line">                    presort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>以下几个参数较为重要</p><blockquote><ul><li><strong>criterion</strong> : string, optional (default=”gini”)<br><u>用以设置用信息熵还是基尼系数计算。</u><br>(1).criterion=’gini’,分裂节点时评价准则是Gini指数。<br>(2).criterion=’entropy’,分裂节点时的评价指标是信息增益(模型欠拟合时使用)。</li><li><strong>max_depth</strong> : int or None, optional (default=None)。<br><u>指定树的最大深度</u>。 如果为None，表示树的深度不限。直到所有的叶子节点都是纯净的，即叶子节点 中所有的样本点都属于同一个类别。或者每个叶子节点包含的样本数小于min_samples_split。</li><li><strong>splitter</strong> : string, optional (default=”best”)。<br><u> 指定分裂节点时的策略。 </u><br>(1).splitter=’best’,表示选择最优的分裂策略。<br>(2).splitter=’random’,表示选择最好的随机切分策略。</li><li><strong>min_samples_leaf</strong> : int, float, optional (default=1)<br><u> 限定每个节点分枝后子节点至少有多少个数据，否则就不分枝</u>。<br>(1).如果为整数，则min_samples_split就是最少样本数。<br>(2).如果为浮点数(0到1之间)，则每个叶子节点最少样本数为ceil(min_samples_leaf * n_samples)</li></ul></blockquote><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在编写代码时，对数据的预处理主要包括对数据的<strong>导入</strong>，<strong>补全</strong>与<strong>删减</strong>，<strong>x与y的选取</strong>，将<strong>字典变量转化为虚拟变量</strong>等</p><ol><li><strong>导入数据</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier </span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridsearchCV</span><br><span class="line">data = pd.read_csv(<span class="string">&quot;your_ducument&quot;</span>)</span><br><span class="line"><span class="comment">#查看数据信息</span></span><br><span class="line">data.info()</span><br><span class="line"><span class="comment">#显示表的前10行</span></span><br><span class="line">data.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><strong>删除特征</strong><br>对于一些不需要的特征，例如<u>明显与因变量关系不大的特征</u>或是<u>缺失值实在太多难以填补的特征</u>可以适当性的直接拿掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">&quot;被拿掉的特征名1，被拿掉特征名2&quot;</span>], inplace = <span class="literal">True</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>inplace = True</code>指的是将替换原有的data,即等价于<code>data = data.drop([&quot;被拿掉的特诊名1，被拿掉特诊名2&quot;],axis = 1)</code>。<br>关于<code>axis = 1</code>,只的是对<strong>列</strong>操作，即对<strong>每一行</strong>操作.</p></blockquote><ol start="3"><li><strong>填充缺失值</strong><br>假设我们有一特征为年龄(age)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用平均值来填补缺失值</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].fillna(data[<span class="string">&quot;age&quot;</span>].mean())</span><br></pre></td></tr></table></figure>当某特征仅缺失较少的值时，把缺失的那个数据所在行删掉即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认有axis = 0,即对整行进行操作</span></span><br><span class="line">data = data.dropna()</span><br></pre></td></tr></table></figure></li><li><strong>类型转换</strong><br>假设我们有一特征<u>楼层(floor)</u>：有first，second，third 三个string值，将其转化为0，1，2。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以得到[&quot;first&quot;,&quot;second&quot;,third]</span></span><br><span class="line">labels = data[<span class="string">&quot;floor&quot;</span>].unique().tolist()</span><br><span class="line"><span class="comment">#index可以返回元素x在列表中的位置</span></span><br><span class="line">data[<span class="string">&quot;floor&quot;</span>] = data[<span class="string">&quot;floor&quot;</span>].apply( <span class="keyword">lambda</span> x : labels.index(x))</span><br></pre></td></tr></table></figure><blockquote><ul><li>关于apply()的具体用法<a class="link"   href="https://blog.csdn.net/anshuai_aw1/article/details/82347016" >见此<i class="fas fa-external-link-alt"></i></a></li></ul></blockquote></li><li><strong>语法补充</strong><br>上述我们一直在使用的<strong>data</strong>是pandas特有的<strong>DataFrame</strong>类型，关于取出其中的某一列特征进行操作可以使用<code>data[&quot;age&quot;]</code>，但最好使用<code>data.loc[:,&quot;age&quot;]</code>或是<code>data.iloc[:,3]</code>。</li></ol><h3 id="分离特征-x-与标签-y"><a href="#分离特征-x-与标签-y" class="headerlink" title="分离特征(x)与标签(y)"></a>分离特征(x)与标签(y)</h3><p>假设我们要取出的标签是<u>楼层(floor)</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = data.iloc[:, data.colums !=<span class="string">&quot;floor&quot;</span>]</span><br><span class="line">y = data.iloc[:, data.colums == <span class="string">&quot;floor&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="划分训练集与测试集"><a href="#划分训练集与测试集" class="headerlink" title="划分训练集与测试集"></a>划分训练集与测试集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取30%为测试集，70%为训练集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtext, Ytrain, Ytest = train_test_split(x, y, test_size = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>此函数随机选取训练集与测试集，会将索引打乱，为了以防万一对后续造成额外影响，有必要纠正索引.</p><blockquote><ul><li>所谓”索引“，是pandas在导入时DataFrame对每一行数据按顺序产生的索引,当输入<code>Xtrain.index</code>时会返回被打乱的索引列表。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#恢复索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [Xtrain, Xtext, Ytrain, Ytest] ： </span><br><span class="line">    i.index = <span class="built_in">range</span>(i.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(random_state = <span class="number">25</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)<span class="comment">#R方</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li><strong>交叉验证</strong> : 指不断随机改变训练集与测试集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10次交叉验证均值</span></span><br><span class="line">cross_score = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br></pre></td></tr></table></figure></li></ul><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><ul><li><strong>基础方法</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tr = []<span class="comment">#训练集拟合程度</span></span><br><span class="line">te = []<span class="comment">#测试集拟合程度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) : </span><br><span class="line"><span class="comment">#调整max_depth，即剪枝</span></span><br><span class="line">    clf = DecisionTreeClassifier(random_state = <span class="number">25</span>, max_depth = i + <span class="number">1</span>)<span class="comment">#random_state为随机数种子</span></span><br><span class="line">    clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">    score_tr = clf.score(Xtest, Ytest)</span><br><span class="line">    score_te = cross_val_score(clf, x, y, cv = <span class="number">10</span>).mean()</span><br><span class="line">    tr.append(score_tr)</span><br><span class="line">    te.append(score_te)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), tr, color = <span class="string">&quot;red&quot;</span>, label = <span class="string">&quot;train&quot;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), te, color = <span class="string">&quot;blue&quot;</span>,label = <span class="string">&quot;test&quot;</span>)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.legend()</span><br><span class="line">ply.show()</span><br></pre></td></tr></table></figure></li><li><strong>网格搜索</strong><br>事实上就是暴力枚举，速度特别慢<br><del>(而且算了半天说不定还没一开始简简单单的好)</del><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parameters = &#123;<span class="string">&quot;criterion&quot;</span>:(<span class="string">&quot;gini&quot;</span>,<span class="string">&quot;entropy&quot;</span>), </span><br><span class="line">                        <span class="string">&quot;spliter&quot;</span>:(<span class="string">&quot;best&quot;</span>,<span class="string">&quot;random&quot;</span>),</span><br><span class="line">                        <span class="string">&quot;max_depth&quot;</span>: [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)],</span><br><span class="line">                        <span class="string">&quot;min_samples_leaf&quot;</span> = [*<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>,<span class="number">5</span>)],</span><br><span class="line">                        <span class="string">&quot;min_impurity_decrease&quot;</span> = np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">50</span>) &#125;</span><br><span class="line">clf = DecisionTreeClassifier(random = <span class="number">25</span>)</span><br><span class="line">GS = GridSearchCV(clf, parameters, cv = <span class="number">10</span>)</span><br><span class="line">GS = GS.fit(Xtrain, Ytrain)</span><br><span class="line">GS.best_params_<span class="comment">#最佳参数组合</span></span><br><span class="line">GS.best_score_<span class="comment">#最佳结果r方</span></span><br></pre></td></tr></table></figure><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3>生成可视化图,在这里仅仅只能输出一个dot文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot_data = export_graphviz(tree,out_file= <span class="string">&quot;result.dot&quot;</span>,class_names[<span class="string">&#x27;serious&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>],feature_names=cancer.feature_names,impurity=<span class="literal">False</span>,filled=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>将.dot文件转为jpg文件，展示可视化图(不知道为啥不可用，要用cmd来转换 <code>dot result.dot -T jpg -o result.jpg)</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(graph,)= pydot.graph_from_dot_file(<span class="string">&#x27;result.dot&#x27;</span>)</span><br><span class="line">graph.write_png(<span class="string">&#x27;tree.png&#x27;</span>)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210125183759997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn决策树&quot;&gt;&lt;a href=&quot;#sklearn决策树&quot; class=&quot;headerlink&quot; title=&quot;sklearn决策树&quot;&gt;&lt;/a&gt;sklearn决策树&lt;/h1&gt;&lt;h3 id=&quot;参数表示&quot;&gt;&lt;a href=&quot;#参数表示&quot; class=&quot;head</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklean" scheme="http://example.com/tags/sklean/"/>
    
    <category term="决策树" scheme="http://example.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(6)PairGrid</title>
    <link href="http://example.com/2021/11/02/seaborn6/"/>
    <id>http://example.com/2021/11/02/seaborn6/</id>
    <published>2021-11-01T17:27:36.000Z</published>
    <updated>2021-11-01T17:29:25.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-6-PairGrid"><a href="#seaborn入门-6-PairGrid" class="headerlink" title="seaborn入门(6)PairGrid"></a>seaborn入门(6)PairGrid</h1><h2 id="PairGrid"><a href="#PairGrid" class="headerlink" title="PairGrid"></a>PairGrid</h2><p>代码和图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">iris_g = sns.PairGrid(iris,hue = <span class="string">&quot;species&quot;</span>)</span><br><span class="line">iris_g.<span class="built_in">map</span>(plt.scatter)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130001248178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>累了，溜了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-6-PairGrid&quot;&gt;&lt;a href=&quot;#seaborn入门-6-PairGrid&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(6)PairGrid&quot;&gt;&lt;/a&gt;seaborn入门(6)PairGrid&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(5)群图(cluster map)</title>
    <link href="http://example.com/2021/11/02/seaborn5/"/>
    <id>http://example.com/2021/11/02/seaborn5/</id>
    <published>2021-11-01T17:25:33.000Z</published>
    <updated>2021-11-01T17:27:18.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-5-群图-cluster-map"><a href="#seaborn入门-5-群图-cluster-map" class="headerlink" title="seaborn入门(5)群图(cluster map)"></a>seaborn入门(5)群图(cluster map)</h1><h2 id="群图-cluster-map"><a href="#群图-cluster-map" class="headerlink" title="群图(cluster map)"></a>群图(cluster map)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(name=<span class="string">&#x27;iris&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">species = iris.pop(<span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(species)</span><br><span class="line">sns.clustermap(iris)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129233342616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>这图可能有亿点点复杂，但其实很简单(<del>并不是</del>)<br>这就是所谓的<strong>分层聚类热图</strong>，首先计算了点与点之间的距离，最接近的会被加入，然后开始比较行与列之间的关系。（<del>说了个几把</del> ）</p><p><strong>让我们稍微换一个简单一点点的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">sns.clustermap(flights,cmap = <span class="string">&quot;Blues&quot;</span>, standard_scale=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>flights代表的是一个二维数组，代表某年某月的乘客人数，<a class="link"   href="https://blog.csdn.net/newsunson/article/details/113408300" >详情见<i class="fas fa-external-link-alt"></i></a></p><p>所以我们得到下面的图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129234934427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>你会发现年份和月份并不是按着顺序排列的，这其实就是一个相当于聚类的过程，你可以把他看成一个聚类后的热力图（<strong>我以为我懂了，仔细一想我好像还是有点懵，希望大佬们来补充一下</strong>）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-5-群图-cluster-map&quot;&gt;&lt;a href=&quot;#seaborn入门-5-群图-cluster-map&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(5)群图(cluster map)&quot;&gt;&lt;/a&gt;seaborn</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(4)关联系数矩阵和热力图</title>
    <link href="http://example.com/2021/11/02/seaborn4/"/>
    <id>http://example.com/2021/11/02/seaborn4/</id>
    <published>2021-11-01T17:24:29.000Z</published>
    <updated>2021-11-01T17:26:51.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-4-关联系数矩阵和热力图"><a href="#seaborn入门-4-关联系数矩阵和热力图" class="headerlink" title="seaborn入门(4)关联系数矩阵和热力图"></a>seaborn入门(4)关联系数矩阵和热力图</h1><h2 id="关联系数矩阵"><a href="#关联系数矩阵" class="headerlink" title="关联系数矩阵"></a>关联系数矩阵</h2><p>这个懂的都懂，大概就是表示两个变量之间的关联性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">tips_mx = tips_df.corr()</span><br><span class="line"><span class="built_in">print</span>(tips_df.corr())</span><br></pre></td></tr></table></figure><p>载入数据有问题看seaborn入门(1)<br>得到如下结果<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230000142.png#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h2><p>我们可以将上面的矩阵可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.heatmap(tips_mx,annot = <span class="literal">True</span> , cmap = <span class="string">&#x27;Blues&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>其中cmap的选择和<a class="link"   href="https://editor.csdn.net/md/?articleId=113408019" >调色盘<i class="fas fa-external-link-alt"></i></a>一样</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129230758969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="酷酷的热力图"><a href="#酷酷的热力图" class="headerlink" title="酷酷的热力图"></a>酷酷的热力图</h2><p>我们采用新的数据，并创建一个数据透视图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(name=<span class="string">&#x27;flights&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line"><span class="comment">#数据透视图创建</span></span><br><span class="line">flights = flights.pivot_table(index = <span class="string">&#x27;month&#x27;</span>,columns = <span class="string">&#x27;year&#x27;</span>, values = <span class="string">&#x27;passengers&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原来的数据是这样的<img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232036805.png#pic_center"                      alt="在这里插入图片描述"                ><br>数据透视图是这样的，表示某年某月某日乘坐飞机的人数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129231848465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>画成热力图就是<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129232302523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br><del>有种马赛克的美感</del> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-4-关联系数矩阵和热力图&quot;&gt;&lt;a href=&quot;#seaborn入门-4-关联系数矩阵和热力图&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(4)关联系数矩阵和热力图&quot;&gt;&lt;/a&gt;seaborn入门(4)关联系数矩阵和热</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(3)调色盘</title>
    <link href="http://example.com/2021/11/02/seaborn3/"/>
    <id>http://example.com/2021/11/02/seaborn3/</id>
    <published>2021-11-01T17:22:20.000Z</published>
    <updated>2021-11-01T17:25:19.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-3-调色盘"><a href="#seaborn入门-3-调色盘" class="headerlink" title="seaborn入门(3)调色盘"></a>seaborn入门(3)调色盘</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><p>续接上文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">sns.set_context(<span class="string">&#x27;talk&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="调色盘"><a href="#调色盘" class="headerlink" title="调色盘"></a>调色盘</h2><p>访问这个界面你能看到调色看给你的一些风格样式<br><code>https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html</code><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129224410260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ><br>例如我选一个夏天风情的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df,jitter = <span class="literal">True</span>,hue = <span class="string">&#x27;sex&#x27;</span>,palette = <span class="string">&#x27;summer&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129225343154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-3-调色盘&quot;&gt;&lt;a href=&quot;#seaborn入门-3-调色盘&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(3)调色盘&quot;&gt;&lt;/a&gt;seaborn入门(3)调色盘&lt;/h1&gt;&lt;h2 id=&quot;基础准备&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(2)继续展示seaborn的各种绘图效果</title>
    <link href="http://example.com/2021/11/02/seaborn2/"/>
    <id>http://example.com/2021/11/02/seaborn2/</id>
    <published>2021-11-01T17:17:55.000Z</published>
    <updated>2021-11-01T17:21:44.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-2"><a href="#seaborn入门-2" class="headerlink" title="seaborn入门(2)"></a>seaborn入门(2)</h1><h2 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h2><p>续接上文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置风格"><a href="#设置风格" class="headerlink" title="设置风格"></a>设置风格</h2><p>共有4种风格可以选，分别是”white”, “dark”, “whitegrid”, “darkgrid”, “ticks”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&quot;dark&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="简单设置图中元素"><a href="#简单设置图中元素" class="headerlink" title="简单设置图中元素"></a>简单设置图中元素</h2><ul><li>设置画布大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><ul><li>设置字体</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(<span class="string">&#x27;paper&#x27;</span>,font_scale=<span class="number">1.4</span>) </span><br></pre></td></tr></table></figure><blockquote><p>其中’paper’为风格，还有talk,poster等风格</p></blockquote><ul><li>设置坐标轴<br>例如下面的代码是删除左边的坐标轴，同理还可以设置<code>bottom = True</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.despine(left = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>男性女性给的小费差异，默认来看是通过男性给小费的平均值和女性给小费的平均值来进行比较，也可以通过中位数<code>estimator = np.media</code>，标准差<code>np.std</code>，协方差<code>np.cov来估计</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x = <span class="string">&#x27;sex&#x27;</span>, y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, estimator=np.mean)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129203730986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="计数图"><a href="#计数图" class="headerlink" title="计数图"></a>计数图</h2><p>与之相比，计数图可以对某个数据集统计数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(x = <span class="string">&#x27;sex&#x27;</span>, data = tips_df)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221529262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h2><p>这种图不是很懂啊，希望有大佬来分析以下QwQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, hue = <span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221720323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h2><p>同上，感觉这图有点骚,大概就是代表数据的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df, hue = <span class="string">&#x27;sex&#x27;</span>,split = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129221827101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="剥离图"><a href="#剥离图" class="headerlink" title="剥离图"></a>剥离图</h2><p>这是一个代表不同数据点的散点图，其中一个变量是分类变量，代表着数据的平均分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df,jitter = <span class="literal">True</span>,)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129222746989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="分簇散点图"><a href="#分簇散点图" class="headerlink" title="分簇散点图"></a>分簇散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x  = <span class="string">&#x27;day&#x27;</span>,y = <span class="string">&#x27;total_bill&#x27;</span>, data = tips_df)</span><br></pre></td></tr></table></figure><p>算是小提琴图的点状形式吧<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129223303445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-2&quot;&gt;&lt;a href=&quot;#seaborn入门-2&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(2)&quot;&gt;&lt;/a&gt;seaborn入门(2)&lt;/h1&gt;&lt;h2 id=&quot;准备数据集&quot;&gt;&lt;a href=&quot;#准备数据集&quot; cla</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>seaborn入门(1)展示seaborn的各种绘图效果</title>
    <link href="http://example.com/2021/11/02/seaborn1/"/>
    <id>http://example.com/2021/11/02/seaborn1/</id>
    <published>2021-11-01T17:13:33.000Z</published>
    <updated>2021-11-01T17:19:10.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seaborn入门-1-展示seaborn的各种绘图效果"><a href="#seaborn入门-1-展示seaborn的各种绘图效果" class="headerlink" title="seaborn入门(1)展示seaborn的各种绘图效果"></a>seaborn入门(1)展示seaborn的各种绘图效果</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="载入数据集"><a href="#载入数据集" class="headerlink" title="载入数据集"></a>载入数据集</h2><p>以下代码可以查看seaborn自带的数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sns.get_dataset_names())</span><br></pre></td></tr></table></figure><p>这里使用<strong>车祸信息</strong>作为原始数据集,按理来说下面代码就可以实现导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash_df = sns.load_dataset(<span class="string">&quot;car_crashes&quot;</span>)</span><br></pre></td></tr></table></figure><p>但实际上，由于不可描述的某种抗力，导致在下载数据集的时候有可能下载不出来(<del>如果你加载出来了当我没说</del>)，所以<strong>需要到github上提前下载数据集</strong>(<a class="link"   href="https://github.com/mwaskom/seaborn-data" >https://github.com/mwaskom/seaborn-data<i class="fas fa-external-link-alt"></i></a>)<u>(建议先导入码云之后再下载)</u>，下载之后将数据集放入与文件相同的目录下，然后使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash_df = sns.load_dataset(name=<span class="string">&quot;car_crashes&quot;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborn-data&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在可以查看表的内容了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(crash_df.head())</span><br></pre></td></tr></table></figure><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>首先，选择你的风格,分别是”white”, “dark”, “whitegrid”, “darkgrid”, “ticks”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&#x27;white&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="简单展示几种绘图方式"><a href="#简单展示几种绘图方式" class="headerlink" title="简单展示几种绘图方式"></a>简单展示几种绘图方式</h3><h4 id="displot"><a href="#displot" class="headerlink" title="displot()"></a>displot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(crash_df[<span class="string">&#x27;not_distracted&#x27;</span>],kde = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195444571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="kdeplot"><a href="#kdeplot" class="headerlink" title="kdeplot()"></a>kdeplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(crash_df[<span class="string">&#x27;speeding&#x27;</span>],crash_df[<span class="string">&#x27;alcohol&#x27;</span>], data = crash_df, shade = </span><br><span class="line"><span class="literal">True</span> ,cbar=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195527693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="jointplot"><a href="#jointplot" class="headerlink" title="jointplot()"></a>jointplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x = <span class="string">&#x27;speeding&#x27;</span>, y = <span class="string">&#x27;alcohol&#x27;</span>, data = crash_df,kind = <span class="string">&#x27;kde&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195543526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="pairplot"><a href="#pairplot" class="headerlink" title="pairplot()"></a>pairplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(crash_df)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195640960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>或者可以使用<strong>hue</strong>分类<u>（这里重新导入了一个数据集）</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips_df = sns.load_dataset(name=<span class="string">&#x27;tips&#x27;</span>,cache=<span class="literal">True</span>,data_home=<span class="string">&quot;./seaborndata&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tips_df.head())</span><br><span class="line">sns.pairplot(tips_df, hue = <span class="string">&#x27;sex&#x27;</span>,)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195651651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="rugplot"><a href="#rugplot" class="headerlink" title="rugplot()"></a>rugplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里用的是上面刚刚载入的数据集</span></span><br><span class="line">sns.rugplot(tips_df[<span class="string">&#x27;tip&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210129195702475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;seaborn入门-1-展示seaborn的各种绘图效果&quot;&gt;&lt;a href=&quot;#seaborn入门-1-展示seaborn的各种绘图效果&quot; class=&quot;headerlink&quot; title=&quot;seaborn入门(1)展示seaborn的各种绘图效果&quot;&gt;&lt;/a&gt;se</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="seaborn" scheme="http://example.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>sklearn随机森林</title>
    <link href="http://example.com/2021/11/02/python-rdf/"/>
    <id>http://example.com/2021/11/02/python-rdf/</id>
    <published>2021-11-01T17:11:37.000Z</published>
    <updated>2021-11-01T17:15:51.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn随机森林"><a href="#sklearn随机森林" class="headerlink" title="sklearn随机森林"></a>sklearn随机森林</h1><p>本文基于菜菜的sklearn教学</p><p>@[toc]</p><h2 id="随机森林分类器"><a href="#随机森林分类器" class="headerlink" title="随机森林分类器"></a>随机森林分类器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随机森林是一种集成算法，即运用大量不同的算法，选出最优的一个，主要是基于决策树。</p><h3 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wine = load_wine()</span><br><span class="line"><span class="built_in">print</span>(wine.data.shape)</span><br><span class="line"><span class="built_in">print</span>(wine.target)</span><br></pre></td></tr></table></figure><h3 id="划分测试集和训练集"><a href="#划分测试集和训练集" class="headerlink" title="划分测试集和训练集"></a>划分测试集和训练集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain,Xtest,Ytrain,Ytest = train_test_split(wine.data,wine.target,test_size = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rfc = RandomForestClassifier(random_state = <span class="number">0</span>)</span><br><span class="line">rfc = rfc.fit(Xtrain,Ytrain)</span><br><span class="line">score_r = rfc.score(Xtest,Ytest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random Forest:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(score_r))</span><br></pre></td></tr></table></figure><p>和决策树几乎一模一样，核心代码似乎也就这么几行：</p><ul><li>建立分类器rfc</li><li>带入数据进行训练</li><li>利用测试集给出评分</li></ul><h3 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h3><p>可以输出模型中每一个特征的重要性程度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rfc.feature_importances_)</span><br></pre></td></tr></table></figure><p>下面是这么多次交叉验证之后所得到的准确率变化</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>Xtest可以换成所需要预测的数据，返回对应的标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfc.predict(Xtest)</span><br></pre></td></tr></table></figure><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>交叉验证就是不断的重新划分训练集和数据集进行验证，注意交叉验证的时候是不用<code>fit()</code>的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">rfc = RandomForestClassifier(n_estimators = <span class="number">25</span>)</span><br><span class="line">rfc_s = cross_val_score(rfc,wine.data,wine.target,cv = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>), rfc_s,label = <span class="string">&quot;RandomForest&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下面给出十次交叉验证的得分<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130190153741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h3 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a>参数讲解</h3><p>随机森林中的参数大多数与决策树中的参数差不多，最重要的是：</p><ul><li>n_estimator 森林中树中的个数，显然个数越多结果越准确。<br>其他的建议<a class="link"   href="https://blog.csdn.net/u011301133/article/details/52562874" >看这位大佬的<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="随机森林回归"><a href="#随机森林回归" class="headerlink" title="随机森林回归"></a>随机森林回归</h2><p>分类和回归的区别其实就是一个变量是分类变量，一个变量是连续变量。对于sklearn来说几乎没什么区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line">boston = load_boston()</span><br><span class="line">reg = RandomForestRegressor(n_estimators = <span class="number">100</span>,random_state = <span class="number">0</span>)</span><br><span class="line">cross_val_score(reg, boston.data, boston.target, cv = <span class="number">10</span> ,scoring = <span class="string">&quot;neg_mean_squared_error&quot;</span>)</span><br></pre></td></tr></table></figure><p>其他都和分类树一样</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><strong>随机森林在乳腺癌数据上的调参</strong></p><h3 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h3><p>下面调用了乳腺癌患者的例子，给出10次交叉验证的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = load_breast_cancer()</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier(n_estimators=<span class="number">100</span>,random_state=<span class="number">90</span>)</span><br><span class="line">score_pre = cross_val_score(rfc,data.data,data.target,cv=<span class="number">10</span>).mean()</span><br><span class="line"><span class="built_in">print</span>(score_pre)</span><br></pre></td></tr></table></figure><p>最后结果为<code>0.9648809523809524</code>，还是比较准确的</p><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>但是我还是不满意，于是我使用了200次循环，每次循环取十次交叉验证的平均值，并逐次增加树的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = load_breast_cancer()</span><br><span class="line"></span><br><span class="line">scorel = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">200</span>,<span class="number">10</span>):</span><br><span class="line">    rfc = RandomForestClassifier(n_estimators=i+<span class="number">1</span>,n_jobs=-<span class="number">1</span>,random_state=<span class="number">90</span>)</span><br><span class="line">    score = cross_val_score(rfc,data.data,data.target,cv=<span class="number">10</span>).mean()</span><br><span class="line">    scorel.append(score)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(scorel),(scorel.index(<span class="built_in">max</span>(scorel))*<span class="number">10</span>)+<span class="number">1</span>)</span><br><span class="line">plt.figure(figsize=[<span class="number">20</span>,<span class="number">5</span>])</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">201</span>,<span class="number">10</span>),scorel)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果有<img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130190141256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>菜菜后面还写了一堆调参的，但对我一个只打一打美赛的菜鸡好像其实用不到这么多，感兴趣的自己去b站搜菜菜的sklearn吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn随机森林&quot;&gt;&lt;a href=&quot;#sklearn随机森林&quot; class=&quot;headerlink&quot; title=&quot;sklearn随机森林&quot;&gt;&lt;/a&gt;sklearn随机森林&lt;/h1&gt;&lt;p&gt;本文基于菜菜的sklearn教学&lt;/p&gt;
&lt;p&gt;@[toc]&lt;/p&gt;</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="rdf" scheme="http://example.com/tags/rdf/"/>
    
  </entry>
  
  <entry>
    <title>sklearn数据预处理和特征工程</title>
    <link href="http://example.com/2021/11/02/python-data-process/"/>
    <id>http://example.com/2021/11/02/python-data-process/</id>
    <published>2021-11-01T17:09:17.000Z</published>
    <updated>2021-11-01T17:16:02.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn数据预处理和特征工程"><a href="#sklearn数据预处理和特征工程" class="headerlink" title="sklearn数据预处理和特征工程"></a>sklearn数据预处理和特征工程</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="数据的无量纲化"><a href="#数据的无量纲化" class="headerlink" title="数据的无量纲化"></a>数据的无量纲化</h3><p>一般来说，当我们将数据导入模型的时候，无量纲化的可以帮我们<strong>去除量纲对模型</strong>的影响（决策树和随机森林不需要这样做，它可以处理大多数数据）<br>一般来说线性的无量纲化包括<strong>去中心化</strong>和<strong>缩放处理</strong>，中心化就是将原本的数据通过加减一个固定值使他进行平移，缩放就是对数据乘除一个固定值使其处于某一种范围之中，例如取对数。</p><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p><strong>归一化处理</strong>，可以将数据缩放到0-1之间<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130213325246.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>上面这个肯定会很眼熟,代码实现还是老三样</p><ul><li>实例化</li><li>用<code>fit()</code>处理数据</li><li>导出结果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = MinMaxScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler = scaler.fit(data) <span class="comment">#fit，在这里本质是生成min(x)和max(x)</span></span><br><span class="line">result = scaler.transform(data) <span class="comment">#导出结果</span></span><br></pre></td></tr></table></figure>或者也可以一步到位<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_ = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure>或者你也可以将数据归一化到其他范围<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scaler = MinMaxScaler(feature_range=</span><br><span class="line">[<span class="number">5</span>,<span class="number">10</span>])</span><br><span class="line">result = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4></li></ul><p><strong>标准化处理</strong>可以将数据缩放到-1-1之间<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/2021013021334539.png#pic_center"                      alt="在这里插入图片描述"                ></p><p>代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = StandardScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler.fit(data) <span class="comment">#fit，本质是生成均值和方差</span></span><br><span class="line">scaler.mean_ <span class="comment">#查看均值</span></span><br><span class="line">scaler.var_ <span class="comment">#查看方差_</span></span><br><span class="line">x_std = scaler.transform(data)</span><br></pre></td></tr></table></figure><h4 id="标准化和归一化如何选择"><a href="#标准化和归一化如何选择" class="headerlink" title="标准化和归一化如何选择"></a>标准化和归一化如何选择</h4><p>在大多数机器学习里都是选择<strong>标准化</strong>来进行特征缩放的。<br>而归一化对于异常值较为敏感，优点是便于计算，可以用在图像处理等方面。</p><h3 id="填补缺失值"><a href="#填补缺失值" class="headerlink" title="填补缺失值"></a>填补缺失值</h3><p>首先导入菜菜给的泰坦尼克号数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">r&quot;D:\2 菜菜的sklearn直播课件\预处理数据\Narrativedata.csv&quot;</span>,index_col= <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210130212959298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age = data.loc[: ,<span class="string">&quot;Age&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>data</code>是pandas的DataFrame结构</li><li><code>data.loc[: ,&quot;Age&quot;]</code>是Age所在行，是一个字典形式的量，即索引对应年龄</li><li><code>data.loc[: ,&quot;Age&quot;].values</code>取出了字典中所有值,即取出所有年龄，是一个一维数组</li><li><code>data.loc[: ,&quot;Age&quot;].values.reshape(-1,1)</code>将其转化二维列向量，<code>reshape(a,b)</code>指的是转化为a行b列的二维向量，其中-1代表自动计算。</li></ul></blockquote><p>依然是</p><ul><li>实例化<code>SimpleImputer()</code></li><li><code>result = fit_transform(yourdata)</code></li><li><code>data.loc[:&quot;Age&quot;] = result</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imp_mean = SimpleImputer() <span class="comment">#实例化，默认均值填补</span></span><br><span class="line">imp_median = SimpleImputer(strategy=<span class="string">&quot;median&quot;</span>) <span class="comment">#用中位数填补</span></span><br><span class="line">imp_0 = SimpleImputer(strategy=<span class="string">&quot;constant&quot;</span>,fill_value=<span class="number">0</span>) <span class="comment">#用0补</span></span><br><span class="line"></span><br><span class="line">imp_mean = imp_mean.fit_transform(Age)</span><br><span class="line">imp_median = imp_median.fit_transform(Age)</span><br><span class="line">imp_0 = imp_0.fit_transform(Age)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在这里我们使用中位数填补Age</span></span><br><span class="line">data.loc[:,<span class="string">&quot;Age&quot;</span>] = imp_median</span><br><span class="line">data.info()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用众数填补Embarked</span></span><br><span class="line">Embarked = data.loc[:,<span class="string">&quot;Embarked&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">imp_mode = SimpleImputer(strategy =<span class="string">&quot;most_frequent&quot;</span>)</span><br><span class="line">data.loc[:,<span class="string">&quot;Embarked&quot;</span>] = imp_mode.fit_transform(Embarked)</span><br><span class="line">data.info()</span><br></pre></td></tr></table></figure><code>data.loc[:,&quot;Age&quot;] = imp_median</code>这里是可以直接赋值的，虽然他两类型不同,一个是字典一个是二维数组<br>也可以<strong>直接用pands和numpy填补</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:,<span class="string">&quot;Age&quot;</span>] = data.loc[:,<span class="string">&quot;Age&quot;</span>].fillna(data.loc[:,<span class="string">&quot;Age&quot;</span>].median())</span><br></pre></td></tr></table></figure>也可以直接将缺失的数据丢掉<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.dropna(axis=</span><br><span class="line"><span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><code>axis = 0</code>代表对行操作，<code>inplace = True</code>代表直接对原数据替换<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3>其实就是将<strong>文字型变量转化为数值型</strong><br>依然是三步：</li><li>实例化<code>LabelEncoder()</code></li><li><code>le.fit_transform(data.iloc[:,2])</code></li><li><code>data.iloc[:,2] = result</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">result = le.fit_transform(data.iloc[:,<span class="number">2</span>])</span><br><span class="line">data.iloc[:,<span class="number">2</span>] = result</span><br></pre></td></tr></table></figure><h3 id="二值化和分段"><a href="#二值化和分段" class="headerlink" title="二值化和分段"></a>二值化和分段</h3><h4 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h4><p>例如我们可以将上述数据二值化，大于30岁的赋值为1，小于30岁的赋值为0<br>嘿嘿，老三样，只是这次又得转为二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line">X = data2.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">bn = Binarizer(threshold = <span class="number">30</span>)</span><br><span class="line">result = bn.fit_transform(X)</span><br></pre></td></tr></table></figure><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>这次KBinsDiscretizer()里面有几个重要参数</p><ul><li><strong>n_bins</strong>是分的类的数量</li><li><strong>encode</strong>是编码方式，’ordinary’,指的是返回一个整数，如分成三个类返回0，1，2构成的数列</li><li><strong>strategy</strong>有三种”uniform”是等宽分类，用最大值与最小值之差除与类的数量作为每个类的宽度,”quantile”是将每个类中的样本数分的都相同,“kmeans”是用kmeans聚类的方法来分类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> KBinsDiscretizer</span><br><span class="line">X = data.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line">est = KBinsDiscretizer(n_bins=<span class="number">3</span>, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">est.fit_transform(X) </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn数据预处理和特征工程&quot;&gt;&lt;a href=&quot;#sklearn数据预处理和特征工程&quot; class=&quot;headerlink&quot; title=&quot;sklearn数据预处理和特征工程&quot;&gt;&lt;/a&gt;sklearn数据预处理和特征工程&lt;/h1&gt;&lt;h2 id=&quot;数据预处理</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>sklearn主成分分析PCA</title>
    <link href="http://example.com/2021/11/02/python-pca/"/>
    <id>http://example.com/2021/11/02/python-pca/</id>
    <published>2021-11-01T17:00:55.000Z</published>
    <updated>2021-11-01T17:07:21.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sklearn主成分分析PCA"><a href="#sklearn主成分分析PCA" class="headerlink" title="sklearn主成分分析PCA"></a>sklearn主成分分析PCA</h1><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>给数学基础不是很好的看<br>PCA主要用于<strong>降维</strong>，比如一个人有<strong>身高，年龄，样貌，性别，智力，耐力，速度，成绩</strong>等等很多<strong>特征</strong>，<strong>每种特征便是一个维度</strong>。假如你觉得描述一个人的特征太多，你想要用<strong>一两个或几个特征</strong>就个以描述一个人，并且<strong>这几个特征包含之前提到所有特征所包含的信息</strong>，将这么原来的众多特征转化为几个特征的过程就是<strong>降维</strong>。而降维后得到的特征包含的<strong>信息量的多少也叫做贡献率</strong>，信息量越多越能够反应本质。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里举一个最常用的水仙花的例子</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>包括sklearn他的好基友们啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>这是一个水仙花的案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">y = iris.target</span><br><span class="line">x = iris.data</span><br></pre></td></tr></table></figure><p>有<code>x.shape = (150, 4)</code>,即每朵花共有四个特征,分别为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iris.feature_names = </span><br><span class="line">                    [<span class="string">&#x27;sepal length (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;sepal width (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;petal length (cm)&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;petal width (cm)&#x27;</span>]</span><br></pre></td></tr></table></figure><p>而<code>y</code>是一个分类变量，分别为<code>[0,1,2]</code>代表三种不同的花</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>还是sklearn中的老三样:</p><ul><li>实例化PCA()</li><li>调用<code>fit()</code>函数</li><li>调用<code>transform()</code>函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pca = PCA(n_components = <span class="number">2</span>)</span><br><span class="line">pca = pca.fit(x)</span><br><span class="line">x_dr = pca.transform(x)</span><br></pre></td></tr></table></figure><blockquote><p>这里<code>n_components</code>表示降维后所得到的维度<br>或者也可以直接一步到位</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_dr = PCA(<span class="number">2</span>).fit_transform(x)</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看降维后所带有的信息量大小"><a href="#查看降维后所带有的信息量大小" class="headerlink" title="查看降维后所带有的信息量大小"></a>查看降维后所带有的信息量大小</h3><ul><li>两个维度信息量大小<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(pca.explained_variance_)</span><br></pre></td></tr></table></figure>可以得到<code>[4.22824171， 0.24267075]</code></li><li>两个维度贡献率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pca.explained_variance_ratio_</span><br></pre></td></tr></table></figure><p>可以得到<code>[0.92461872, 0.05306648]</code></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>当我们把数据降维后，可以观察其在新的维度上的分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">0</span>,<span class="number">0</span>],x_dr[y == <span class="number">0</span>,<span class="number">1</span>],c = <span class="string">&quot;red&quot;</span>,label = iris.target_names[<span class="number">0</span>])</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">1</span>,<span class="number">0</span>],x_dr[y == <span class="number">1</span>,<span class="number">1</span>],c = <span class="string">&quot;black&quot;</span>,label = iris.target_names[<span class="number">1</span>])</span><br><span class="line">plt.scatter(x_dr[y == <span class="number">2</span>,<span class="number">0</span>],x_dr[y == <span class="number">2</span>,<span class="number">1</span>],c = <span class="string">&quot;orange&quot;</span>,label = iris.target_names[<span class="number">2</span>])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p>其中<code>x_dr[y = 0,0]用了布尔索引</code></p></blockquote><p>得到如下结果<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201123828720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><p>可以这是一个分簇的分布，也就是说降维之后其实已经比较好分类了</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="累计方差贡献率曲线"><a href="#累计方差贡献率曲线" class="headerlink" title="累计方差贡献率曲线"></a>累计方差贡献率曲线</h4><p>当选取维度不同时累计贡献率的曲线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_line = PCA().fit(x)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],np.cumsum(pca_line.explained_variance_ratio_))</span><br><span class="line">plt.xticks([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img-blog.csdnimg.cn/20210201123816813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld3N1bnNvbg==,size_16,color_FFFFFF,t_70#pic_center"                      alt="在这里插入图片描述"                ></p><h4 id="最大似然估计选择超参数"><a href="#最大似然估计选择超参数" class="headerlink" title="最大似然估计选择超参数"></a>最大似然估计选择超参数</h4><p>这种方法可以自动选出最合适的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_mle = PCA(n_components = <span class="string">&quot;mle&quot;</span>)</span><br><span class="line">pca_mle = pca_mle.fit(x)</span><br><span class="line">x_mle = pca_mle.transform(x)</span><br><span class="line">pca_mle.explained_variance_ratio_.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>比如上述例子为我们选了维度为3，累计贡献率高达0.994</p><h4 id="按贡献率选择"><a href="#按贡献率选择" class="headerlink" title="按贡献率选择"></a>按贡献率选择</h4><p>意味着你想要他的累计贡献率达到0.97时的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca_f = PCA(n_components=<span class="number">0.97</span>,svd_solver=<span class="string">&quot;full&quot;</span>)</span><br><span class="line">pca_f = pca_f.fit(x)</span><br><span class="line">x_f = pca_f.transform(x)</span><br><span class="line"><span class="built_in">print</span>(pca_f.explained_variance_ratio_)</span><br></pre></td></tr></table></figure><p>贡献率分别为<code>[0.92461872, 0.05306648]</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn主成分分析PCA&quot;&gt;&lt;a href=&quot;#sklearn主成分分析PCA&quot; class=&quot;headerlink&quot; title=&quot;sklearn主成分分析PCA&quot;&gt;&lt;/a&gt;sklearn主成分分析PCA&lt;/h1&gt;&lt;h2 id=&quot;数学原理&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="sklearn" scheme="http://example.com/tags/sklearn/"/>
    
    <category term="pca" scheme="http://example.com/tags/pca/"/>
    
  </entry>
  
</feed>
